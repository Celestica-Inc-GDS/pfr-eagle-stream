#include <iostream>
#include <stdlib.h>
#include <openssl/x509.h>
#include <openssl/pem.h>

// Include the GTest headers
#include "gtest_headers.h"

// Include the SYSTEM MOCK and PFR headers
#include "ut_nios_wrapper.h"

class PFRCertFlowTest : public testing::Test
{
public:

    // CFM0/CFM1 binary content used in this test suite
    alt_u32* m_cfm0_image;
    alt_u32* m_cfm1_image;

    // Pointer to start of CFM0/CFM1
    alt_u32* m_cfm0_ufm_ptr;
    alt_u32* m_cfm1_ufm_ptr;

    virtual void SetUp()
    {
        SYSTEM_MOCK* sys = SYSTEM_MOCK::get();
        // Reset system mocks and SPI flash
        sys->reset();
        sys->reset_spi_flash_mock();

        // Perform provisioning
        SYSTEM_MOCK::get()->provision_ufm_data(UFM_PFR_DATA_EXAMPLE_KEY_FILE);

        // Reset Nios firmware
        ut_reset_nios_fw();

        // Load the entire image to flash
        SYSTEM_MOCK::get()->load_to_flash(SPI_FLASH_BMC, FULL_PFR_IMAGE_BMC_FILE, FULL_PFR_IMAGE_BMC_FILE_SIZE);
        SYSTEM_MOCK::get()->load_to_flash(SPI_FLASH_PCH, FULL_PFR_IMAGE_PCH_FILE, FULL_PFR_IMAGE_PCH_FILE_SIZE);

        // Initialize CFM0
        m_cfm0_image = new alt_u32[UFM_CPLD_ROM_IMAGE_LENGTH/4];
        SYSTEM_MOCK::get()->init_x86_mem_from_file(CFM0_RECOVERY_IMAGE_FILE, m_cfm0_image);
        m_cfm0_ufm_ptr = get_ufm_ptr_with_offset(UFM_CPLD_ROM_IMAGE_OFFSET);
        for (alt_u32 i = 0; i < (UFM_CPLD_ROM_IMAGE_LENGTH/4); i++)
        {
            m_cfm0_ufm_ptr[i] = m_cfm0_image[i];
        }

        // Initialize CFM1
        m_cfm1_image = new alt_u32[UFM_CPLD_ACTIVE_IMAGE_LENGTH/4];
        SYSTEM_MOCK::get()->init_x86_mem_from_file(CFM1_ACTIVE_IMAGE_FILE, m_cfm1_image);
        m_cfm1_ufm_ptr = get_ufm_ptr_with_offset(UFM_CPLD_ACTIVE_IMAGE_OFFSET);
        for (alt_u32 i = 0; i < (UFM_CPLD_ACTIVE_IMAGE_LENGTH/4); i++)
        {
            m_cfm1_ufm_ptr[i] = m_cfm1_image[i];
        }
    }

    virtual void TearDown()
    {
        delete[] m_cfm0_image;
        delete[] m_cfm1_image;
    }
};

void test_preparation() {
    /*
     * Flow preparation
     */
    // Exit after 10 iterations in the T0 loop
    SYSTEM_MOCK::get()->insert_code_block(SYSTEM_MOCK::CODE_BLOCK_TYPES::T0_OPERATIONS_END_AFTER_50_ITERS);

    // Set asserts to throw as opposed to abort
    SYSTEM_MOCK::get()->set_assert_to_throw();
    // Throw after performing CFM switch
    SYSTEM_MOCK::get()->insert_code_block(SYSTEM_MOCK::CODE_BLOCK_TYPES::THROW_AFTER_CFM_SWITCH);

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    ut_run_main(CPLD_CFM0, true);
    ut_run_main(CPLD_CFM1, false);

    // Expect no error
    EXPECT_EQ(read_from_mailbox(MB_MAJOR_ERROR_CODE), alt_u32(0));
    EXPECT_EQ(read_from_mailbox(MB_MINOR_ERROR_CODE), alt_u32(0));
}

/**
 * @brief Use openssl library d2i_X509_fp and X509_verify_cert() functions to parse the DER certificate generated by the fw code.
 * FW DER encoding is done correctly for cert generation if DER certificate can be parsed successfully by openssl function.
 */
TEST_F(PFRCertFlowTest, test_certificate_generation_verify_selfsigned_der_encoding)
{
    test_preparation();

    // generate DER certificate into buffer
    alt_u8 der_cert_buffer[FULL_CERT_LENGTH_ROOT];
    alt_u32 expected_der_cert_length = FULL_CERT_LENGTH_ROOT;
    alt_u32 der_cert_length = pfr_generate_der_certificate_root(der_cert_buffer, get_ufm_ptr_with_offset(UFM_CPLD_PUBLIC_KEY_1), get_ufm_ptr_with_offset(UFM_CPLD_PUBLIC_KEY_1), get_ufm_ptr_with_offset(UFM_CPLD_PRIVATE_KEY_1));

    EXPECT_GE(expected_der_cert_length, der_cert_length);

    // write DER encoded cert into .der file
    // openssl requires a target .der to parse to verify DER encoding
    FILE *generated_der_cert_file;
    char der_cert_filename[] = X509_CERT_GENERATE_SELFSIGNED_TEST_OUTPUT_DER_FILE;
    generated_der_cert_file  = fopen (der_cert_filename, "w");
    for (alt_u32 i = 0; i < der_cert_length; i++) {
        fputc(der_cert_buffer[i], generated_der_cert_file);
    }
    fclose(generated_der_cert_file);

    generated_der_cert_file = fopen(der_cert_filename, "rb");
    if(generated_der_cert_file)
    {
        X509* x509_cert_der_parse = NULL;
        x509_cert_der_parse = d2i_X509_fp(generated_der_cert_file, NULL);
        if(x509_cert_der_parse)
        {
            X509_STORE_CTX *ctx;
            ctx = X509_STORE_CTX_new();
            X509_STORE *store = X509_STORE_new();
            X509_STORE_add_cert(store, x509_cert_der_parse);
            X509_STORE_CTX_init(ctx, store, x509_cert_der_parse, NULL);
            if( 1 == X509_verify_cert(ctx) ) {
                // Certificate verified
            } else {
                GTEST_NONFATAL_FAILURE_("Failed: openssl failed to verify FW DER encoded cert file:\n");
                printf("%s\n", X509_verify_cert_error_string(ctx->error));
            }
            X509_STORE_CTX_free(ctx);
            X509_STORE_free(store);

        }
        else
        {
            GTEST_NONFATAL_FAILURE_("Failed: openssl failed to parse FW DER encoded cert file");
        }
        X509_free(x509_cert_der_parse);
        fclose(generated_der_cert_file);
    }
    else
    {
        GTEST_NONFATAL_FAILURE_("Failed: failed to generate .der cert file for openssl to parse/ verify");
    }

}

/**
 * @brief Use FW pfr_verify_der_certificate() function to verify certificate generate by FW in preceding unit-test (test_certificate_generation_verify_der_encoding).
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_generated_selfsigned_certificate)
{

    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_CERT_GENERATE_SELFSIGNED_TEST_OUTPUT_DER_FILE;
    alt_u8 der_cert_buffer[4096];
    sample_der_cert_file = fopen(sample_cert_filename, "rb");

    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    alt_u32 cert_cx[SHA384_LENGTH/4];
    alt_u32 cert_cy[SHA384_LENGTH/4];
    alt_u32 sig_r[SHA384_LENGTH/4];
    alt_u32 sig_s[SHA384_LENGTH/4];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL == pfr_verify_der_certificate(der_cert_buffer, buffer_size, cert_cx, cert_cy, cert_cx, cert_cy, sig_r, sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: certificate verification failed");
    }

}

/**
 * @brief Use openssl library d2i_X509_fp and X509_verify_cert() functions to parse the DER certificate generated by the fw code.
 * FW DER encoding is done correctly for cert generation if DER certificate can be parsed successfully by openssl function.
 */
TEST_F(PFRCertFlowTest, test_certificate_generation_verify_certificate_chain_der_encoding)
{
    test_preparation();

    // get certificate chain from UFM (generated during attestatin preparation flow)
    // get layer 0 cert
    alt_u8* layer_0_cert_buffer = (alt_u8*) get_ufm_cpld_cert_ptr() + 52;
    alt_u32 layer_0_cert_length = pfr_get_certificate_size(layer_0_cert_buffer);
    // get layer 1 cert
    alt_u8* layer_1_cert_buffer = &layer_0_cert_buffer[layer_0_cert_length];
    alt_u32 layer_1_cert_length = pfr_get_certificate_size(layer_1_cert_buffer);

    alt_u32 expected_der_root_cert_length = FULL_CERT_LENGTH_ROOT;
    alt_u32 expected_der_leaf_cert_length = FULL_CERT_LENGTH_LEAF;

    EXPECT_GE(expected_der_root_cert_length, layer_0_cert_length);
    EXPECT_GE(expected_der_leaf_cert_length, layer_1_cert_length);

    // write DER encoded layer 0 cert into .der file
    // openssl requires a target .der to parse to verify DER encoding
    FILE *generated_der_layer_0_cert_file;
    char der_layer_0_cert_filename[] = X509_CERT_GENERATE_CHAIN_LAYER_0_TEST_OUTPUT_DER_FILE;
    generated_der_layer_0_cert_file  = fopen (der_layer_0_cert_filename, "w");
    for (alt_u32 i = 0; i < layer_0_cert_length; i++) {
        fputc(layer_0_cert_buffer[i], generated_der_layer_0_cert_file);
    }
    fclose(generated_der_layer_0_cert_file);

    // write DER encoded layer 1 cert into .der file
    // openssl requires a target .der to parse to verify DER encoding
    FILE *generated_der_layer_1_cert_file;
    char der_layer_1_cert_filename[] = X509_CERT_GENERATE_CHAIN_LAYER_1_TEST_OUTPUT_DER_FILE;
    generated_der_layer_1_cert_file  = fopen (der_layer_1_cert_filename, "w");
    for (alt_u32 i = 0; i < layer_1_cert_length; i++) {
        fputc(layer_1_cert_buffer[i], generated_der_layer_1_cert_file);
    }
    fclose(generated_der_layer_1_cert_file);


    FILE *generated_der_cert_chain_file;
    char der_cert_chain_filename[] = "testdata/x509_certificate/test_certificate_generation_verify_der_encoding_chain_certificate.der";
    generated_der_cert_chain_file  = fopen (der_cert_chain_filename, "w");
    for (alt_u32 i = 0; i < layer_0_cert_length; i++) {
        fputc(layer_0_cert_buffer[i], generated_der_cert_chain_file);
    }
    for (alt_u32 i = 0; i < layer_1_cert_length; i++) {
        fputc(layer_1_cert_buffer[i], generated_der_cert_chain_file);
    }
    fclose(generated_der_cert_chain_file);

    FILE *generated_der_cert_file0;
    generated_der_cert_file0 = fopen(der_cert_chain_filename, "rb");
    if(generated_der_cert_file0)
    {
        X509* x509_cert_der_parse = NULL;
        x509_cert_der_parse = d2i_X509_fp(generated_der_cert_file0, NULL);
        if(x509_cert_der_parse)
        {
            X509_STORE_CTX *ctx;
            ctx = X509_STORE_CTX_new();
            X509_STORE *store = X509_STORE_new();
            X509_STORE_add_cert(store, x509_cert_der_parse);
            X509_STORE_CTX_init(ctx, store, x509_cert_der_parse, NULL);
            if( 1 == X509_verify_cert(ctx) ) {
                // Certificate verified
            } else {
                GTEST_NONFATAL_FAILURE_("Failed: openssl failed to verify FW DER encoded cert chain file:\n");
                printf("%s\n", X509_verify_cert_error_string(ctx->error));
            }
            X509_STORE_CTX_free(ctx);
            X509_STORE_free(store);

        }
        else
        {
            GTEST_NONFATAL_FAILURE_("Failed: openssl failed to parse FW DER encoded cert chain file");
        }
        X509_free(x509_cert_der_parse);
        fclose(generated_der_cert_file0);
    }
    else
    {
        GTEST_NONFATAL_FAILURE_("Failed: failed to generate .der cert chain file for openssl to parse/ verify");
    }

    FILE *generated_der_cert_file;
    generated_der_cert_file = fopen(der_layer_0_cert_filename, "rb");
    if(generated_der_cert_file)
    {
        X509* x509_cert_der_parse = NULL;
        x509_cert_der_parse = d2i_X509_fp(generated_der_cert_file, NULL);
        if(x509_cert_der_parse)
        {
            // DER parse successful; FW performed DER encoding correctly
            // following disable code writes DER cert into PEM cert
            FILE *pem_cert_file;
            char pem_cert_filename[] = X509_CERT_GENERATE_CHAIN_LAYER_0_TEST_OUTPUT_PEM_FILE;
            pem_cert_file = fopen(pem_cert_filename, "w");
            if(pem_cert_file)
            {
                PEM_write_X509(pem_cert_file, x509_cert_der_parse);
                fclose(pem_cert_file);
            }


            X509_STORE_CTX *ctx;
            ctx = X509_STORE_CTX_new();
            X509_STORE *store = X509_STORE_new();
            X509_STORE_add_cert(store, x509_cert_der_parse);
            X509_STORE_CTX_init(ctx, store, x509_cert_der_parse, NULL);
            if( 1 == X509_verify_cert(ctx) ) {
                // Certificate verified
            } else {
                GTEST_NONFATAL_FAILURE_("Failed: openssl failed to verify FW DER encoded layer 0 cert file:\n");
                printf("%s\n", X509_verify_cert_error_string(ctx->error));
            }
            X509_STORE_CTX_free(ctx);
            X509_STORE_free(store);

        }
        else
        {
            GTEST_NONFATAL_FAILURE_("Failed: openssl failed to parse FW DER encoded layer 0 cert file");
        }
        X509_free(x509_cert_der_parse);
        fclose(generated_der_cert_file);
    }
    else
    {
        GTEST_NONFATAL_FAILURE_("Failed: failed to generate .der layer 0 cert file for openssl to parse/ verify");
    }

}

/**
 * @brief Use FW pfr_verify_der_cert_chain() function to verify certificate chain generate by FW in preceding unit-test (test_certificate_generation_verify_certificate_chain_der_encoding).
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_generated_certificate_chain)
{

    FILE *sample_der_layer_0_cert_file;
    char sample_layer_0_cert_filename[] = X509_CERT_GENERATE_CHAIN_LAYER_0_TEST_OUTPUT_DER_FILE;
    sample_der_layer_0_cert_file = fopen(sample_layer_0_cert_filename, "rb");

    FILE *sample_der_layer_1_cert_file;
    char sample_layer_1_cert_filename[] = X509_CERT_GENERATE_CHAIN_LAYER_1_TEST_OUTPUT_DER_FILE;
    sample_der_layer_1_cert_file = fopen(sample_layer_1_cert_filename, "rb");

    // load layer 0 and layer 1 der certs into buffer to create cert chain
    alt_u8 der_cert_buffer[4096];
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_layer_0_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_layer_0_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_layer_0_cert_file);
    while(!feof(sample_der_layer_1_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_layer_1_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_layer_1_cert_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL == pfr_verify_der_cert_chain(der_cert_buffer, buffer_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: certificate chain verification failed");
    }

    if ( buffer_size != pfr_certificate_get_chain_size(der_cert_buffer, 2) ) {
        GTEST_NONFATAL_FAILURE_("Failed: certificate chain size calculation failed");
    }

}

/**
 * @brief Use FW pfr_verify_der_cert_chain() function to verify certificate chain generate by FW in preceding unit-test (test_certificate_generation_verify_certificate_chain_der_encoding).
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_on_empty_and_null_buffers)
{

    alt_u8 cert_cx[SHA384_LENGTH];
	alt_u8 cert_cy[SHA384_LENGTH];
	alt_u8 sig_r[SHA384_LENGTH];
	alt_u8 sig_s[SHA384_LENGTH];
	CERT_EXTENSION_CONTEXT cert_extension_context;
	CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
	reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    alt_u8 der_cert_buffer[4096];
    for ( alt_u32 buffer_size = 0; buffer_size < 4096; buffer_size++ ) {
        der_cert_buffer[buffer_size] = 0x00;
    }

    EXPECT_EQ(alt_u32(0), pfr_get_certificate_size(der_cert_buffer));
    EXPECT_EQ(alt_u32(0), pfr_certificate_get_chain_length(der_cert_buffer, 4096));
    EXPECT_EQ(alt_u32(0), pfr_certificate_get_chain_size(der_cert_buffer, 2));
    EXPECT_EQ(alt_u32(CERTIFICATE_VERIFY_FAIL), pfr_verify_der_certificate(der_cert_buffer, 4096, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr));
    EXPECT_EQ(alt_u32(CERTIFICATE_VERIFY_FAIL), pfr_verify_der_certificate(der_cert_buffer, 4096, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, INTERMEDIATE_CERT, cert_extension_context_ptr));
    EXPECT_EQ(alt_u32(CERTIFICATE_VERIFY_FAIL), pfr_verify_der_certificate(der_cert_buffer, 4096, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, LEAF_CERT, cert_extension_context_ptr));
    EXPECT_EQ(alt_u8(CERTIFICATE_VERIFY_FAIL), pfr_verify_der_cert_chain(der_cert_buffer, 2, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy));

    for ( alt_u32 buffer_size = 0; buffer_size < 4096; buffer_size++ ) {
        der_cert_buffer[buffer_size] = 0xff;
    }

    EXPECT_EQ(alt_u32(0), pfr_get_certificate_size(der_cert_buffer));
    EXPECT_EQ(alt_u32(0), pfr_certificate_get_chain_length(der_cert_buffer, 4096));
    EXPECT_EQ(alt_u32(0), pfr_certificate_get_chain_size(der_cert_buffer, 2));
    EXPECT_EQ(alt_u32(CERTIFICATE_VERIFY_FAIL), pfr_verify_der_certificate(der_cert_buffer, 4096, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr));
    EXPECT_EQ(alt_u32(CERTIFICATE_VERIFY_FAIL), pfr_verify_der_certificate(der_cert_buffer, 4096, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, INTERMEDIATE_CERT, cert_extension_context_ptr));
    EXPECT_EQ(alt_u32(CERTIFICATE_VERIFY_FAIL), pfr_verify_der_certificate(der_cert_buffer, 4096, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, LEAF_CERT, cert_extension_context_ptr));
    EXPECT_EQ(alt_u8(CERTIFICATE_VERIFY_FAIL), pfr_verify_der_cert_chain(der_cert_buffer, 2, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy));

}

/**
 * @brief pfr_verify_der_certificate() verify certificate with signature rs INTEGERs with value lengths = 48
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_sample_signature_verification_sig_rs_length_r48_s48)
{

    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL == pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: certificate verification failed");
    }

    alt_u8 expected_cert_cx[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_CX;
    alt_u8 expected_cert_cy[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_CY;
    alt_u8 expected_cert_sig_r[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SIG_R;
    alt_u8 expected_cert_sig_s[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SIG_S;
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_cx[i], cert_cx[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_cy[i], cert_cy[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_sig_r[i], sig_r[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_sig_s[i], sig_s[i]);
    }

}

/**
 * @brief pfr_verify_der_certificate() verify certificate with signature rs INTEGERs with value lengths = 49
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_sample_signature_verification_sig_rs_length_r49_s49)
{

    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_49;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL == pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: certificate verification failed");
    }

    alt_u8 expected_cert_cx[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_49_CX;
    alt_u8 expected_cert_cy[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_49_CY;
    alt_u8 expected_cert_sig_r[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_49_SIG_R;
    alt_u8 expected_cert_sig_s[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_49_SIG_S;
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_cx[i], cert_cx[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_cy[i], cert_cy[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_sig_r[i], sig_r[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_sig_s[i], sig_s[i]);
    }

}

/**
 * @brief pfr_verify_der_certificate() verify certificate with signature rs INTEGERs with value lengths 48 and 49 respectively
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_sample_signature_verification_sig_rs_length_r48_s49)
{

    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_49;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL == pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: certificate verification failed");
    }

    alt_u8 expected_cert_cx[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_49_CX;
    alt_u8 expected_cert_cy[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_49_CY;
    alt_u8 expected_cert_sig_r[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_49_SIG_R;
    alt_u8 expected_cert_sig_s[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_49_SIG_S;
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_cx[i], cert_cx[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_cy[i], cert_cy[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_sig_r[i], sig_r[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_sig_s[i], sig_s[i]);
    }

}

/**
 * @brief pfr_verify_der_certificate() verify certificate with signature rs INTEGERs with value lengths 49 and 48 respectively
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_sample_signature_verification_sig_rs_length_r49_s48)
{

    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL == pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: certificate verification failed");
    }

    alt_u8 expected_cert_cx[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_48_CX;
    alt_u8 expected_cert_cy[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_48_CY;
    alt_u8 expected_cert_sig_r[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_48_SIG_R;
    alt_u8 expected_cert_sig_s[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_48_SIG_S;
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_cx[i], cert_cx[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_cy[i], cert_cy[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_sig_r[i], sig_r[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_sig_s[i], sig_s[i]);
    }

}

/**
 * @brief pfr_verify_der_certificate() verify certificate with signature rs INTEGERs with value lengths 48 and 47 respectively
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_sample_signature_verification_sig_rs_length_r48_s47)
{

    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_47;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL == pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: certificate verification failed");
    }

    alt_u8 expected_cert_cx[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_47_CX;
    alt_u8 expected_cert_cy[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_47_CY;
    alt_u8 expected_cert_sig_r[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_47_SIG_R;
    alt_u8 expected_cert_sig_s[SHA384_LENGTH] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_47_SIG_S;
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_cx[i], cert_cx[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_cy[i], cert_cy[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_sig_r[i], sig_r[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_cert_sig_s[i], sig_s[i]);
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_signature_algorithm_ecdsawith384)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // corrupt certificate signature algorithm ecdsaWith384 oid
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_CERT_SIGNATURE_ALGORITHM_OFFSET + SHORT_DER_SIZE] = 0xFF;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect corrupted certificate signature algorithm: ecdsaWith384");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_version)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // corrupt certificate signature algorithm ecdsaWith384 oid
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_VERSION_OFFSET + SHORT_DER_SIZE] = 0x01;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect corrupted certificate version: 3");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_signed_content_signature_algorithm_ecdsawith384)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // corrupt signature algorithm ecdsaWith384 oid in to-be-signed certificate
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SIGNED_CONTENT_SIGNATURE_ALGORITHM_OFFSET + SHORT_DER_SIZE] = 0xFF;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect corrupted certificate signature algorithm in to-be-signed certificate: ecdsaWith384");
    }

}

/**
 * @brief certificate 'validity from' value is later than 'validity till' period
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_validity_from_till_reversed)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // reverse validity period from and till datetime values
    alt_u8 validity_temp[CERT_VALIDITY_UTCTIME_LENGTH];
    alt_u8_memcpy(validity_temp , &der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_VALIDITY_PERIOD_FROM_OFFSET + SHORT_DER_SIZE], CERT_VALIDITY_UTCTIME_LENGTH);
    alt_u8_memcpy(&der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_VALIDITY_PERIOD_FROM_OFFSET + SHORT_DER_SIZE] , &der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_VALIDITY_PERIOD_TILL_OFFSET + SHORT_DER_SIZE], CERT_VALIDITY_UTCTIME_LENGTH);
    alt_u8_memcpy(&der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_VALIDITY_PERIOD_TILL_OFFSET + SHORT_DER_SIZE] , validity_temp, CERT_VALIDITY_UTCTIME_LENGTH);


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid validity period: validity from datetime is later than validity till datetime");
    }

}

/**
 * @brief expired certificate validity
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_validity_expired)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // write expired validity period into cert
    alt_u8 validity_expired[CERT_VALIDITY_UTCTIME_LENGTH] = {'1','8','0','1','0','1','0','0','0','0','0','0','Z'};
    alt_u8_memcpy(&der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_VALIDITY_PERIOD_FROM_OFFSET + SHORT_DER_SIZE] , validity_expired, CERT_VALIDITY_UTCTIME_LENGTH);
    alt_u8_memcpy(&der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_VALIDITY_PERIOD_TILL_OFFSET + SHORT_DER_SIZE] , validity_expired, CERT_VALIDITY_UTCTIME_LENGTH);


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid validity period: expired certificate (validity till 1800-01-01 00:00:00)");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_subject_public_key_info_ecpublickey)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // corrupt subject public key info ecPublicKey oid
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SUBJECT_PUBLIC_KEY_INFO_ECPUBLICKEY_OID_OFFSET + SHORT_DER_SIZE] = 0xFF;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect corrupted subject public key info: ecPublicKey");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_subject_public_key_info_secp384r1)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // corrupt subject public key info secp384r1 oid
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SUBJECT_PUBLIC_KEY_INFO_SECP384R1_OID_OFFSET + SHORT_DER_SIZE] = 0xFF;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect corrupted subject public key info: secp384r1");
    }

}

/**
 * @brief corrupting signed content to cause signature verification to fail
 */
TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_corrupt_signed_content)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // corrupt subject public key in signed content, so signature verification fails
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SUBJECT_PUBLIC_KEY_INFO_PUBLIC_KEY_OFFSET + 10] = 0xFF;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: signature verification passed despite corrupted signed content");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_corrupt_certificate_signature)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // corrupt subject public key in signed content, so signature verification fails
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SIGNATURE_OFFSET + 10] = 0xFF;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: signature verification passed despite corrupted certificate signature");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_corrupt_length_case1)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // alter buffer_size limit
    buffer_size = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SIZE - 1;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect certificate invalidity");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_corrupt_length_case2)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // alter signed content length value
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_CERT_SEQUENCE_LENGTH_OFFSET] = 0x03;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect certificate invalidity");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_corrupt_length_case3)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // alter signed content length value
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SIGNED_CONTENT_LENGTH_OFFSET] = 0x02;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect certificate invalidity");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_corrupt_length_case4)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // alter signed content length value
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SIGNED_CONTENT_LENGTH_OFFSET] = 0x00;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect certificate invalidity");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_corrupt_length_case5)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // alter certificate signature algorithm length value
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SIGNATURE_ALGORITHM_LENGTH_OFFSET] = 0x09;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect certificate invalidity");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_corrupt_length_case6)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // alter certificate signature length value
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_CERTIFICATE_SIGNATURE_LENGTH_OFFSET] = 0x57;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect certificate invalidity");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_corrupt_length_case7)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // alter validity period length value
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_VALIDITY_PERIOD_LENGTH_OFFSET] = 0x1D;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect certificate invalidity");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_corrupt_length_case8)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    // alter subject's public key info length value
    der_cert_buffer[X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SUBJECT_PUBLIC_KEY_INFO_LENGTH_OFFSET] = 0x75;


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect certificate invalidity");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_duplicate_extensions_basic_constraints)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_DUPLICATE_EXTENSIONS_BASIC_CONSTRAINTS;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect duplicate extension (each extension may only appear once)");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_duplicate_extensions_key_usage)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_DUPLICATE_EXTENSIONS_KEY_USAGE;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect duplicate extension (each extension may only appear once)");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_verify_certificate_negative_case_duplicate_extensions_extended_key_usage)
{
    test_preparation();

    // load sample certificate
    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_DUPLICATE_EXTENSIONS_EXTENDED_KEY_USAGE;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);


    alt_u8 cert_cx[SHA384_LENGTH];
    alt_u8 cert_cy[SHA384_LENGTH];
    alt_u8 sig_r[SHA384_LENGTH];
    alt_u8 sig_s[SHA384_LENGTH];
    CERT_EXTENSION_CONTEXT cert_extension_context;
    CERT_EXTENSION_CONTEXT* cert_extension_context_ptr = &cert_extension_context;
    reset_buffer((alt_u8*)cert_extension_context_ptr, sizeof(CERT_EXTENSION_CONTEXT));

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_certificate(der_cert_buffer, buffer_size, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) cert_cx, (alt_u32*) cert_cy, (alt_u32*) sig_r, (alt_u32*) sig_s, ROOT_CERT, cert_extension_context_ptr) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect duplicate extension (each extension may only appear once)");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_get_length_1)
{

    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    alt_u32 expected_der_size = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_48_SIZE;
    ASSERT_EQ(expected_der_size, pfr_get_certificate_size(der_cert_buffer));

}

TEST_F(PFRCertFlowTest, test_certificate_get_length_2)
{

    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_49;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    alt_u32 expected_der_size = X509_SAMPLE_CERT_DER_FILE_SIG_RS_48_49_SIZE;
    ASSERT_EQ(expected_der_size, pfr_get_certificate_size(der_cert_buffer));

}

TEST_F(PFRCertFlowTest, test_certificate_get_length_3)
{

    FILE *sample_der_cert_file;
    char sample_cert_filename[] = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_49;
    alt_u8 der_cert_buffer[4096];

    sample_der_cert_file = fopen(sample_cert_filename, "rb");
    alt_u32 buffer_size = 0;
    while(!feof(sample_der_cert_file)){
        der_cert_buffer[buffer_size] = fgetc(sample_der_cert_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_der_cert_file);

    alt_u32 expected_der_size = X509_SAMPLE_CERT_DER_FILE_SIG_RS_49_49_SIZE;
    ASSERT_EQ(expected_der_size, pfr_get_certificate_size(der_cert_buffer));

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_certificate_chain_sample)
{

    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_CERTIFICATE_CHAIN_0_SIZE;
    alt_u32 expected_cert_chain_length = X509_SAMPLE_CERT_CHAIN_DER_FILE_CERTIFICATE_CHAIN_0_LENGTH;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_CERTIFICATE_CHAIN_0;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    buffer_size--;
    fclose(sample_cert_chain_file);

    ASSERT_EQ(expected_cert_chain_size, pfr_certificate_get_chain_size(cert_chain_buffer, expected_cert_chain_length));

    ASSERT_EQ(expected_cert_chain_length, pfr_certificate_get_chain_length(cert_chain_buffer, expected_cert_chain_size));

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    ASSERT_EQ(CERTIFICATE_VERIFY_PASS, pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy));

    // check expected lead public key values
    alt_u8 expected_leaf_cert_cx[SHA384_LENGTH] = X509_SAMPLE_CERT_CHAIN_DER_FILE_CERTIFICATE_CHAIN_0_LEAF_CX;
    alt_u8 expected_leaf_cert_cy[SHA384_LENGTH] = X509_SAMPLE_CERT_CHAIN_DER_FILE_CERTIFICATE_CHAIN_0_LEAF_CY;
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_leaf_cert_cx[i], leaf_cert_cx[i]);
    }
    for (alt_u32 i = 0; i < SHA384_LENGTH; i++) {
        EXPECT_EQ(expected_leaf_cert_cy[i], leaf_cert_cy[i]);
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_invalid_extension_root_cert_not_ca)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_ROOT_CERT_NOT_CA_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_ROOT_CERT_NOT_CA;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid extension");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_invalid_extension_root_cert_no_key_usage_set)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_ROOT_CERT_NO_KEY_USAGE_SET_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_ROOT_CERT_NO_KEY_USAGE_SET;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid extension");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_invalid_extension_root_cert_missing_key_cert_sign_key_usage)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_ROOT_CERT_MISSING_KEY_CERT_SIGN_KEY_USAGE_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_ROOT_CERT_MISSING_KEY_CERT_SIGN_KEY_USAGE;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid extension");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_invalid_extension_root_cert_missing_serverauth_clientauth_extended_key_usage)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_ROOT_CERT_MISSING_SERVERAUTH_CLIENTAUTH_EXTENDED_KEY_USAGE_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_ROOT_CERT_MISSING_SERVERAUTH_CLIENTAUTH_EXTENDED_KEY_USAGE;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid extension");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_invalid_extension_leaf_cert_is_ca)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_LEAF_CERT_IS_CA_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_LEAF_CERT_IS_CA;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid extension");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_invalid_extension_leaf_cert_missing_digital_signature_key_usage)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_LEAF_CERT_MISSING_DIGITAL_SIGNATURE_KEY_USAGE_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_LEAF_CERT_MISSING_DIGITAL_SIGNATURE_KEY_USAGE;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid extension");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_invalid_extension_leaf_cert_contains_key_cert_sign_key_usage)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_LEAF_CERT_CONTAINS_KEY_CERT_SIGN_KEY_USAGE_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_LEAF_CERT_CONTAINS_KEY_CERT_SIGN_KEY_USAGE;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid extension");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_invalid_extension_leaf_cert_missing_serverauth_clientauth_extended_key_usage)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_LEAF_CERT_MISSING_SERVERAUTH_CLIENTAUTH_EXTENDED_KEY_USAGE_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_INVALID_EXTENSION_LEAF_CERT_MISSING_SERVERAUTH_CLIENTAUTH_EXTENDED_KEY_USAGE;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid extension");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_path_length_constraints_positive_case_1)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_0_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_0;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    ASSERT_EQ(CERTIFICATE_VERIFY_PASS, pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy));

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_path_length_constraints_positive_case_2)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_1_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_1;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    ASSERT_EQ(CERTIFICATE_VERIFY_PASS, pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy));

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_path_length_constraints_positive_case_3)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_2_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_2;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    ASSERT_EQ(CERTIFICATE_VERIFY_PASS, pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy));

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_path_length_constraints_positive_case_4)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_3_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_3;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    ASSERT_EQ(CERTIFICATE_VERIFY_PASS, pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy));

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_path_length_constraints_positive_case_5)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_4_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_4;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    ASSERT_EQ(CERTIFICATE_VERIFY_PASS, pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy));

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_path_length_constraints_positive_case_6)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_5_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_5;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    ASSERT_EQ(CERTIFICATE_VERIFY_PASS, pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy));

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_path_length_constraints_positive_case_7)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_6_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_6;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    ASSERT_EQ(CERTIFICATE_VERIFY_PASS, pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy));

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_path_length_constraints_negative_case_1)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_7_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_7;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid path length constraint values");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_path_length_constraints_negative_case_2)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_8_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_8;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid path length constraint values");
    }

}

TEST_F(PFRCertFlowTest, test_certificate_chain_verify_path_length_constraints_negative_case_3)
{
    alt_u32 expected_cert_chain_size = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_9_SIZE;

    FILE *sample_cert_chain_file;
    char sample_cert_chain_filename[] = X509_SAMPLE_CERT_CHAIN_DER_FILE_PATH_LENGTH_CONSTRAINT_TEST_9;
    sample_cert_chain_file = fopen(sample_cert_chain_filename, "rb");

    // load der cert chain into buffer
    alt_u8 cert_chain_buffer[4096] = {0};
    alt_u32 buffer_size = 0;
    while(!feof(sample_cert_chain_file)){
        cert_chain_buffer[buffer_size] = fgetc(sample_cert_chain_file);
        buffer_size++;
    }
    fclose(sample_cert_chain_file);

    alt_u8 leaf_cert_cx[SHA384_LENGTH];
    alt_u8 leaf_cert_cy[SHA384_LENGTH];

    if ( CERTIFICATE_VERIFY_FAIL != pfr_verify_der_cert_chain(cert_chain_buffer, expected_cert_chain_size, (alt_u32*) leaf_cert_cx, (alt_u32*) leaf_cert_cy) ) {
        GTEST_NONFATAL_FAILURE_("Failed: fail to detect invalid path length constraint values");
    }

}

TEST_F(PFRCertFlowTest, test_disrupt_cpld_key_creation_during_boot_up)
{
    test_preparation();

    // CASE 1: no disruption

    // Expect only a single erase is done upon first boot up assuming no disruption
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(1));

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    alt_u32* cfm0_uds = get_ufm_ptr_with_offset(CFM0_UNIQUE_DEVICE_SECRET);
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect no "extra" page erase as the keys generated are exactly the same
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(1));

    // CASE 2: a disruption to public key 0

    // Simulate key disruption during boot up
    *get_ufm_ptr_with_offset(UFM_CPLD_PUBLIC_KEY_0) = 0xabadcafe;

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect another page erase to copy over new keys and certificate to replace the incomplete/corrupted keys
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(2));

    // CASE 3: no disruption

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect no "extra" page erase as the keys generated are exactly the same
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(2));

    // CASE 4: another disruption

    // Simulate key disruption during boot up
    *get_ufm_ptr_with_offset(UFM_CPLD_PUBLIC_KEY_0 + 24) = 0xabadcafe;

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect another page erase to copy over new keys and certificate to replace the incomplete/corrupted keys
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(3));
}

TEST_F(PFRCertFlowTest, test_disrupt_cpld_cert_creation_during_boot_up)
{
    test_preparation();

    // CASE 1: no disruption

    // Expect only a single erase is done upon first boot up assuming no disruption
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(1));

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    alt_u32* cfm0_uds = get_ufm_ptr_with_offset(CFM0_UNIQUE_DEVICE_SECRET);
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect no "extra" page erase as the certs generated are valid
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(1));

    // CASE 2: a disruption to cert

    // Simulate cert disruption during boot up
    *get_ufm_cpld_cert_ptr() = 0xabadcafe;

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect another page erase to copy over new keys and certificate to replace the incomplete/corrupted cert
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(2));

    // CASE 3: no disruption

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect no "extra" page erase as the certs generated are exactly valid
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(2));

    // CASE 4: another disruption

    // Simulate cert disruption during boot up
    *(get_ufm_cpld_cert_ptr() + 16) = 0xabadcafe;

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect another page erase to copy over new keys and certificate to replace the incomplete/corrupted certs
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(3));
}

TEST_F(PFRCertFlowTest, test_disrupt_cpld_cert_and_key_creation_during_boot_up)
{
    test_preparation();

    // CASE 1: no disruption

    // Expect only a single erase is done upon first boot up assuming no disruption
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(1));

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    alt_u32* cfm0_uds = get_ufm_ptr_with_offset(CFM0_UNIQUE_DEVICE_SECRET);
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect no "extra" page erase as the certs generated are valid
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(1));

    // CASE 2: a disruption to cert

    // Simulate cert disruption during boot up
    *get_ufm_cpld_cert_ptr() = 0xabadcafe;

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect another page erase to copy over new keys and certificate to replace the incomplete/corrupted cert
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(2));

    // CASE 3: no disruption

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect no "extra" page erase as the certs generated are exactly valid
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(2));

    // CASE 4: another disruption

    // Simulate cert disruption during boot up
    *(get_ufm_cpld_cert_ptr() + 16) = 0xabadcafe;

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect another page erase to copy over new keys and certificate to replace the incomplete/corrupted certs
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(3));

    // Simulate key disruption during boot up
    *get_ufm_ptr_with_offset(UFM_CPLD_PUBLIC_KEY_0) = 0xabadcafe;

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect another page erase to copy over new keys and certificate to replace the incomplete/corrupted keys
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(4));

    // Simulate key disruption during boot up
    *get_ufm_ptr_with_offset(UFM_CPLD_PUBLIC_KEY_0) = 0xabadcafe;
    // Simulate cert disruption during boot up
    *get_ufm_cpld_cert_ptr() = 0xabadcafe;

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    prep_for_attestation(cfm0_uds, CRYPTO_384_MODE);

    // Expect another page erase to copy over new keys and certificate to replace the incomplete/corrupted keys
    // Expect CPLD to erase once more only eventhough both key and cert are corrupted
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(5));
}

TEST_F(PFRCertFlowTest, test_cert_creation_with_entropy_error)
{
    // Expect no erase is done
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(0));

    /*
     * Run Nios FW through PFR/Recovery Main
     */
    alt_u32* cfm0_uds = get_ufm_ptr_with_offset(CFM0_UNIQUE_DEVICE_SECRET);

    // Force health to fail within the crypto mock
    SYSTEM_MOCK::get()->force_mock_entropy_error();

    EXPECT_EQ(prep_for_attestation(cfm0_uds, CRYPTO_384_MODE), alt_u32(0));

    // Expect no "extra" page erase as failure is due to entropy circuit
    EXPECT_EQ(SYSTEM_MOCK::get()->get_ufm_erase_page_counter(), alt_u32(0));

    // Expect cert to not be stored
    EXPECT_EQ(*get_ufm_cpld_cert_ptr(), (alt_u32)0xffffffff);
}
