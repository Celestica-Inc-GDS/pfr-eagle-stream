#include <iostream>
#include <chrono>
#include <openssl/ec.h>
#include <openssl/obj_mac.h>
#include <openssl/bn.h>
#include <openssl/objects.h>
#include <openssl/ecdsa.h>
#include <openssl/evp.h>

// Include the GTest headers
#include "gtest_headers.h"

// Include the SYSTEM MOCK and PFR headers
#include "ut_nios_wrapper.h"

class PFRCryptoTest : public testing::Test
{
public:

/*
    alt_u8 hash_384_ipad_data_1[384] = {
    		0x38, 0x44, 0x50, 0xc1, 0xb6, 0x10, 0x70, 0xca, 0xc5, 0x84, 0x9f, 0x40,
			0x98, 0xdf, 0xe0, 0x0f, 0xb8, 0xff, 0x6a, 0x2c, 0x63, 0xab, 0x56, 0xbb,
			0x0b, 0x80, 0xc9, 0x6d, 0xe7, 0x0e, 0xad, 0x41, 0xe5, 0x0a, 0x93, 0x89,
			0x08, 0x25, 0xa5, 0x73, 0x5e, 0x8e, 0x79, 0x5d, 0xee, 0xc5, 0x43, 0x64,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3};

    alt_u8 hash_384_ipad_opad_data_2[176] = {
    		0x52, 0x2e, 0x3a, 0xab, 0xdc, 0x7a, 0x1a, 0xa0, 0xaf, 0xee, 0xf5, 0x2a,
			0xf2, 0xb5, 0x8a, 0x65, 0xd2, 0x95, 0x00, 0x46, 0x09, 0xc1, 0x3c, 0xd1,
			0x61, 0xea, 0xa3, 0x07, 0x8d, 0x64, 0xc7, 0x2b, 0x8f, 0x60, 0xf9, 0xe3,
			0x62, 0x4f, 0xcf, 0x19, 0x34, 0xe4, 0x13, 0x37, 0x84, 0xaf, 0x29, 0x0e,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x23, 0xf2, 0x78, 0x20,
			0xbc, 0x06, 0x12, 0xc6, 0xc3, 0x38, 0xc8, 0x5f, 0x02, 0x57, 0xba, 0x3d,
			0x02, 0xe9, 0xe7, 0x3f, 0x1c, 0x3a, 0x39, 0xe5, 0xef, 0x0f, 0xdf, 0xdb,
			0x85, 0x4a, 0x31, 0x46, 0xb9, 0x24, 0xcf, 0x84, 0x04, 0x47, 0xfc, 0x28,
			0xf0, 0xe8, 0xdb, 0xc4, 0xb6, 0x8c, 0xbd, 0xb9
			};

    alt_u8 hash_256_ipad_data_1[256] = {
  		  0xb8, 0xff, 0x6a, 0x2c, 0x63, 0xab, 0x56, 0xbb, 0x0b, 0x80, 0xc9, 0x6d,
  		  0xe7, 0x0e, 0xad, 0x41, 0xe5, 0x0a, 0x93, 0x89, 0x08, 0x25, 0xa5, 0x73,
  		  0x5e, 0x8e, 0x79, 0x5d, 0xee, 0xc5, 0x43, 0x64, 0x36, 0x36, 0x36, 0x36,
  		  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  		  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  		  0x36, 0x36, 0x36, 0x36, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
		  0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
		  0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
		  0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	      0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
		  0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
		  0xa3, 0xa3, 0xa3, 0xa3};

    alt_u8 hash_256_ipad_opad_data_2[96] = {
  		  0xd2, 0x95, 0x00, 0x46, 0x09, 0xc1, 0x3c, 0xd1, 0x61, 0xea, 0xa3, 0x07,
  		  0x8d, 0x64, 0xc7, 0x2b, 0x8f, 0x60, 0xf9, 0xe3, 0x62, 0x4f, 0xcf, 0x19,
  		  0x34, 0xe4, 0x13, 0x37, 0x84, 0xaf, 0x29, 0x0e, 0x5c, 0x5c, 0x5c, 0x5c,
  		  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  		  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
  		  0x5c, 0x5c, 0x5c, 0x5c, 0x53, 0xc5, 0xad, 0xc1, 0xe6, 0xaa, 0x11, 0x36,
		  0x3a, 0x5d, 0xe8, 0x41, 0x69, 0xdb, 0xb2, 0x96, 0xcb, 0x4b, 0x6e, 0xdc,
		  0x72, 0x75, 0x55, 0x3b, 0x56, 0x42, 0x30, 0xfb, 0xbf, 0x17, 0xd9, 0x2b};
*/
    /*alt_u8 td_crypto_data_48[48] = {
        0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
        0x81, 0x17, 0xb7, 0xf6, 0x8d, 0xd8, 0xa3, 0x6c, 0xbf, 0xfa, 0xd0, 0x7d,
        0xde, 0x60, 0x74, 0xc1, 0x65, 0xfa, 0x42, 0x65, 0xbf, 0xfa, 0xd0, 0x7d,
        0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38};*/

   /* alt_u8 td_crypto_data_32[32] = {
        0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
        0x81, 0x17, 0xb7, 0xf6, 0x8d, 0xd8, 0xa3, 0x6c, 0xbf, 0xfa, 0xd0, 0x7d,
        0xde, 0x60, 0x74, 0xc1, 0x65, 0xfa, 0x42, 0x65};*/

    virtual void SetUp() {
        SYSTEM_MOCK::get()->reset();

        //SYSTEM_MOCK::get()->write_x86_mem_to_file("testdata/48_data.hex", td_crypto_data_48, 48);
        //SYSTEM_MOCK::get()->write_x86_mem_to_file("testdata/32_data.hex", td_crypto_data_32, 32);
        //SYSTEM_MOCK::get()->write_x86_mem_to_file("testdata/384_opad_ipad_data.hex", hash_384_ipad_opad_data_2, 176);
        //SYSTEM_MOCK::get()->write_x86_mem_to_file("testdata/256_opad_ipad_data.hex", hash_256_ipad_opad_data_2, 96);
}
    virtual void TearDown() {}
};

TEST_F(PFRCryptoTest, test_crypto_block_ready)
{
    // After reset the CSR should be 0
    EXPECT_EQ(IORD(CRYPTO_CSR_ADDR, 0), (alt_u32) 0);

    EXPECT_EQ(IORD(CRYPTO_DATA_ADDR, 0), (alt_u32) 0);

    EXPECT_EQ(IORD(CRYPTO_ENTROPY_SOURCE_OUTPUT_ADDR(0), 0), (alt_u32) 0);

    for (alt_u32 i = 0; i < 12; i++)
    {
        EXPECT_EQ(IORD(CRYPTO_ECDSA_DATA_CX_OUTPUT_ADDR(i), 0), (alt_u32) 0);
        EXPECT_EQ(IORD(CRYPTO_ECDSA_DATA_CY_OUTPUT_ADDR(i), 0), (alt_u32) 0);
        EXPECT_EQ(IORD(CRYPTO_DATA_SHA_ADDR(i), 0), (alt_u32) 0);
    }
}

TEST_F(PFRCryptoTest, test_crypto_mock_read_all_addr)
{
    // Set asserts to throw as opposed to abort
    SYSTEM_MOCK::get()->set_assert_to_throw();

    EXPECT_NO_THROW(IORD(CRYPTO_CSR_ADDR, 0));

    EXPECT_NO_THROW(IORD(CRYPTO_DATA_ADDR, 0));

    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(0), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(1), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(2), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(3), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(4), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(5), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(6), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(7), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(8), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(9), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(10), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(11), 0));
}

TEST_F(PFRCryptoTest, test_51_bytes_data_sha_only_unaligned)
{
    const alt_u32 td_sha_data_len = 51;

    const alt_u8 td_crypto_data[51] = {
            0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
            0x81, 0x17, 0xb7, 0xf6, 0x8d, 0xd8, 0xa3, 0x6c, 0xbf, 0xfa, 0xd0, 0x7d,
            0xde, 0x60, 0x74, 0xc1, 0x65, 0xfa, 0x42, 0x65, 0xbf, 0xfa, 0xd0, 0x7d,
            0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
            0xdd, 0xaa, 0xcc};

    const alt_u8 td_expected_hash[SHA256_LENGTH] = {
        0x1c, 0x37, 0xba, 0xfa, 0x24, 0x67, 0xff, 0x23, 0x57, 0xa7, 0xf7, 0xa1,
        0x63, 0x06, 0x58, 0xf5, 0xeb, 0xab, 0x8b, 0xdc, 0xcb, 0x18, 0x7d, 0xe8,
        0xde, 0x69, 0x9c, 0x53, 0x47, 0x90, 0x19, 0x81};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_256_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_97_bytes_data_sha_only_unaligned)
{
    const alt_u32 td_sha_data_len = 97;

    const alt_u8 td_crypto_data[97] = {
            0x55, 0x05, 0xdf, 0xf8, 0xbd, 0xaa, 0x28, 0x42, 0x85, 0x82, 0x97, 0x88,
        	0x58, 0x28, 0x58, 0x9b, 0x1c, 0xeb, 0x0d, 0xda, 0xe2, 0xf8, 0x4a, 0x3f,
        	0x78, 0xcd, 0x7a, 0x7f, 0x72, 0x9f, 0x25, 0x64, 0x50, 0x9a, 0xdc, 0xdd,
        	0xd1, 0xb4, 0x57, 0xa1, 0xb4, 0xa7, 0x6b, 0x8e, 0x4f, 0x1d, 0xe9, 0xbf,
        	0x5e, 0x46, 0x77, 0xee, 0x95, 0x1b, 0x61, 0xeb, 0xc8, 0x23, 0x32, 0xbe,
        	0x40, 0x1b, 0xa0, 0x36, 0xe5, 0x35, 0xd5, 0xe5, 0xa9, 0x4e, 0x06, 0x81,
        	0x7f, 0x92, 0x96, 0xa6, 0x03, 0xa6, 0x40, 0x36, 0xb1, 0xe9, 0x01, 0xf5,
        	0x51, 0xf4, 0x90, 0x18, 0xf7, 0x61, 0xbb, 0xd2, 0x2c, 0x37, 0x5d, 0xa2,
        	0xaa};

    const alt_u8 td_expected_hash[SHA256_LENGTH] = {
    		  0x4e, 0x88, 0xe1, 0xa6, 0x01, 0xbb, 0x93, 0x5f, 0x3e, 0xd8, 0x6a, 0x3f,
    		  0xe9, 0x2e, 0xc8, 0x71, 0x19, 0xc5, 0x30, 0x93, 0x62, 0x63, 0xbc, 0x74,
    		  0x6d, 0x4b, 0xee, 0xe7, 0x4d, 0x96, 0x49, 0x70};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_256_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_130_bytes_data_sha_only_unaligned)
{
    const alt_u32 td_sha_data_len = 130;

    const alt_u8 td_crypto_data[130] = {
        	0x13, 0x91, 0x89, 0xca, 0xe6, 0x00, 0x0d, 0xa3, 0xce, 0x06, 0x00, 0xb5,
        	0x2e, 0x0a, 0x36, 0x31, 0xb3, 0x9f, 0xd2, 0x5b, 0x6c, 0x43, 0x1c, 0x07,
        	0x8a, 0x17, 0xf3, 0x64, 0xd6, 0x95, 0x6c, 0x53, 0xd4, 0xd2, 0x4c, 0x77,
        	0x2d, 0x01, 0x3f, 0x87, 0x4d, 0x4c, 0xd0, 0xa2, 0x81, 0x0a, 0xde, 0x59,
        	0x49, 0x44, 0x38, 0xd4, 0xf0, 0x76, 0x7f, 0x6d, 0xcd, 0x90, 0xd6, 0xd0,
        	0xab, 0xac, 0xe3, 0xde, 0x11, 0x38, 0x3e, 0x6f, 0xb7, 0xd2, 0x40, 0x89,
        	0x4d, 0x80, 0x4c, 0x63, 0x2f, 0x3f, 0xc9, 0x9a, 0x26, 0xe0, 0x56, 0x5b,
        	0xf0, 0xf6, 0x59, 0xa1, 0xda, 0xc4, 0xd3, 0x38, 0xd3, 0x3a, 0x30, 0x6f,
        	0x0f, 0xda, 0xe2, 0x27, 0x36, 0xe4, 0xae, 0x50, 0x7f, 0x28, 0xed, 0xc5,
        	0x9c, 0x96, 0x88, 0x90, 0x9b, 0x97, 0xf0, 0xe5, 0x61, 0x0f, 0x6a, 0xa6,
        	0x62, 0x87, 0x3d, 0x9c, 0x6b, 0xe3, 0x21, 0x22, 0xaa, 0xaa};

    const alt_u8 td_expected_hash[SHA256_LENGTH] = {
    	0x39, 0x5f, 0x2c, 0x79, 0x35, 0xdb, 0x2d, 0x19, 0x53, 0x60, 0xa3, 0x0e,
    	0xaf, 0x1c, 0x7a, 0x7b, 0xb8, 0x76, 0x2d, 0xfd, 0xd6, 0xd6, 0x03, 0xda,
    	0x6c, 0x0d, 0x59, 0xd8, 0x5b, 0x54, 0xdd, 0xff};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_256_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_32_bytes_data_sha_only)
{
    const alt_u32 td_sha_data_len = 32;

    const alt_u8 td_crypto_data[32] = {
        0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
        0x81, 0x17, 0xb7, 0xf6, 0x8d, 0xd8, 0xa3, 0x6c, 0xbf, 0xfa, 0xd0, 0x7d,
        0xde, 0x60, 0x74, 0xc1, 0x65, 0xfa, 0x42, 0x65};

    const alt_u8 td_expected_hash[SHA256_LENGTH] = {
        0xb0, 0xa2, 0xd9, 0x58, 0x0c, 0x6a, 0xc9, 0x5b, 0x01, 0xb7, 0x58, 0xef,
        0xf9, 0xaa, 0x41, 0x9e, 0x91, 0x4a, 0x6a, 0xbd, 0x28, 0xc2, 0xc0, 0xf8,
        0x9a, 0xc1, 0x62, 0x80, 0xdf, 0x1a, 0xb9, 0x5c};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_256_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_48_bytes_data_sha_only)
{
    const alt_u32 td_sha_data_len = 48;

    const alt_u8 td_crypto_data[48] = {
        0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
        0x81, 0x17, 0xb7, 0xf6, 0x8d, 0xd8, 0xa3, 0x6c, 0xbf, 0xfa, 0xd0, 0x7d,
        0xde, 0x60, 0x74, 0xc1, 0x65, 0xfa, 0x42, 0x65, 0xbf, 0xfa, 0xd0, 0x7d,
        0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38};

    const alt_u8 td_expected_hash[SHA256_LENGTH] = {
        0xbd, 0x68, 0x5a, 0x41, 0xd4, 0xcc, 0x4d, 0x9e, 0x62, 0xc3, 0xea, 0xc4,
        0x14, 0x17, 0x91, 0x1f, 0x9e, 0x19, 0x5c, 0xa0, 0x63, 0x84, 0x81, 0xc3,
        0xa4, 0x21, 0x40, 0x4d, 0xc5, 0x85, 0x06, 0x95};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_256_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_64_bytes_data_sha_only)
{
    const alt_u32 td_sha_data_len = 64;

    const alt_u8 td_crypto_data[64] = {
        0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
        0x81, 0x17, 0xb7, 0xf6, 0x8d, 0xd8, 0xa3, 0x6c, 0xbf, 0xfa, 0xd0, 0x7d,
        0xde, 0x60, 0x74, 0xc1, 0x65, 0xfa, 0x42, 0x65, 0x49, 0x29, 0x95, 0x1b,
        0xef, 0xb9, 0x83, 0xf0, 0xf6, 0xc1, 0x46, 0xd6, 0x15, 0x73, 0xfa, 0x09,
        0x75, 0xc6, 0x4e, 0x64, 0xf1, 0xde, 0x34, 0x5f, 0x89, 0xf0, 0x61, 0x5d,
        0x61, 0xb4, 0x08, 0x9d};

    const alt_u8 td_expected_hash[SHA256_LENGTH] = {
        0x6b, 0xa4, 0xa6, 0x98, 0x53, 0x63, 0xf0, 0xe7,
        0xe9, 0x98, 0x76, 0x62, 0x7d, 0xe7, 0x12, 0x41, 0xda, 0xab, 0x4b, 0x96,
        0xbd, 0x67, 0x99, 0x82, 0x81, 0x40, 0x27, 0x87, 0xa5, 0x10, 0x6e, 0x73,};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_256_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_single_block_pattern_sha_only)
{
    // ###################################################################################################################################
    // Generating pattern 0 of 128 bytes (1024 bits)
    // Test Data block 0:
    // 1024'h44BD5317988365A3924CD72EE0C8EC394024F6236D173B3BE4F3EFCB510B34CA9EF2F3BFF6C48E2AD772580FB27D4160AB8F26B1B61D876C6C73F75A1F789CFFE4D3DB20751AF87E9172E9A75BDC99FD964108B7E7B7D2F43F065AA5FEEEDE899CE34E4C4B136CB8F8ADF8B3538731231CA87A01425299B7DC7B7E0522C859EC
    // Digest : 256'hA37C4FD5F1F46D462091B9E92D22C6E9CE3097EFE9CD4B25E8F23A2DDD36DDFC
    // Generating curve
    // Using curve prime256v1
    // Generating private key
    // Private Key:
    //      256'hA07DF98A6BE1EA1E6B9C132E4E04A5AB652AEB7A660BC447943B56E7B8B62F19
    // Pubkey:
    //  CX : 256'hCD021AE9F1D8D74B4B11ABF9667CCE94
    //  CY : 256'h8F09B8B0EB68B4D9D447A39EDD1F3A0A

    // echo
    // "44BD5317988365A3924CD72EE0C8EC394024F6236D173B3BE4F3EFCB510B34CA9EF2F3BFF6C48E2AD772580FB27D4160AB8F26B1B61D876C6C73F75A1F789CFFE4D3DB20751AF87E9172E9A75BDC99FD964108B7E7B7D2F43F065AA5FEEEDE899CE34E4C4B136CB8F8ADF8B3538731231CA87A01425299B7DC7B7E0522C859EC"
    // | xxd -r -p | openssl dgst -sha256 (stdin)=
    // a37c4fd5f1f46d462091b9e92d22c6e9ce3097efe9cd4b25e8f23a2ddd36ddfc

    // Generate for C:
    // echo
    // "44BD5317988365A3924CD72EE0C8EC394024F6236D173B3BE4F3EFCB510B34CA9EF2F3BFF6C48E2AD772580FB27D4160AB8F26B1B61D876C6C73F75A1F789CFFE4D3DB20751AF87E9172E9A75BDC99FD964108B7E7B7D2F43F065AA5FEEEDE899CE34E4C4B136CB8F8ADF8B3538731231CA87A01425299B7DC7B7E0522C859EC"
    // | xxd -r -p | xxd -i echo "A37C4FD5F1F46D462091B9E92D22C6E9CE3097EFE9CD4B25E8F23A2DDD36DDFC"
    // | xxd -r -p | xxd -i

    const alt_u32 td_sha_data_len = 128;

    const alt_u8 td_crypto_data[128] = {
        0x44, 0xbd, 0x53, 0x17, 0x98, 0x83, 0x65, 0xa3, 0x92, 0x4c, 0xd7, 0x2e, 0xe0, 0xc8, 0xec,
        0x39, 0x40, 0x24, 0xf6, 0x23, 0x6d, 0x17, 0x3b, 0x3b, 0xe4, 0xf3, 0xef, 0xcb, 0x51, 0x0b,
        0x34, 0xca, 0x9e, 0xf2, 0xf3, 0xbf, 0xf6, 0xc4, 0x8e, 0x2a, 0xd7, 0x72, 0x58, 0x0f, 0xb2,
        0x7d, 0x41, 0x60, 0xab, 0x8f, 0x26, 0xb1, 0xb6, 0x1d, 0x87, 0x6c, 0x6c, 0x73, 0xf7, 0x5a,
        0x1f, 0x78, 0x9c, 0xff, 0xe4, 0xd3, 0xdb, 0x20, 0x75, 0x1a, 0xf8, 0x7e, 0x91, 0x72, 0xe9,
        0xa7, 0x5b, 0xdc, 0x99, 0xfd, 0x96, 0x41, 0x08, 0xb7, 0xe7, 0xb7, 0xd2, 0xf4, 0x3f, 0x06,
        0x5a, 0xa5, 0xfe, 0xee, 0xde, 0x89, 0x9c, 0xe3, 0x4e, 0x4c, 0x4b, 0x13, 0x6c, 0xb8, 0xf8,
        0xad, 0xf8, 0xb3, 0x53, 0x87, 0x31, 0x23, 0x1c, 0xa8, 0x7a, 0x01, 0x42, 0x52, 0x99, 0xb7,
        0xdc, 0x7b, 0x7e, 0x05, 0x22, 0xc8, 0x59, 0xec};

    const alt_u8 td_expected_hash[SHA256_LENGTH] = {
        0xa3, 0x7c, 0x4f, 0xd5, 0xf1, 0xf4, 0x6d, 0x46, 0x20, 0x91, 0xb9,
        0xe9, 0x2d, 0x22, 0xc6, 0xe9, 0xce, 0x30, 0x97, 0xef, 0xe9, 0xcd,
        0x4b, 0x25, 0xe8, 0xf2, 0x3a, 0x2d, 0xdd, 0x36, 0xdd, 0xfc};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_256_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_single_block_pattern_sha_and_ec)
{
    /*
     * Test Data block :
     1024'h863A608FDC3B3965A80A8227439BA56CA04B0E7ECE832B29A58880CF8D08275AEFB121D3B7EC96C3CE5C1B63D198D3397206D7A08185148DE4468D113EC8D938F2EB8EB6056F99CA325012E3BCC5AF27082BECD8B63DAF37412F941BAC089930E4C0D901DFC6B3DA87029FDA4D3B258DCCB80B962E0350ECBD517F28DAB6DD09
     * Digest : 256'hFB62DED71EE9009AD54A9885DE6EE6CB5C7D261DB13320DC919FAA1DCEAD89AF
     * Generating curve
     * Using curve prime256v1
     * Private Key:
         256'hC51E4753AFDEC1E6B6C6A5B992F43F8DD0C7A8933072708B6522468B2FFB06FD
     * Pubkey:
     *   CX : 256'h942C9F408EAD9D82D34A1B9A6A827EBE3E2DDF782B448D23BE1B6143988CCEF4
     *   CY : 256'h8C9EAF6C0D14D992FC63BAD3E2496BE2EEE61CB5B97F65F428CA94A5D0EE19A1
     * Hash:
     *   E :  256'hFB62DED71EE9009AD54A9885DE6EE6CB5C7D261DB13320DC919FAA1DCEAD89AF
     * Signature:
     *   R :  256'h6BD9606BFF8142C667531604E15AA03911474514DFDFDF84EBEB2DA857C83377
     *   S :  256'h4FD46C71183C2BB7CA47030CEE81E2EEC9E317B912243325F273855A66C76D5E
     *
     * Generate for C:
     * % echo "4FD46C71183C2BB7CA47030CEE81E2EEC9E317B912243325F273855A66C76D5E" | xxd -r -p | xxd
     -i
     */
    const alt_u32 test_data_size = 128;

    const alt_u8 test_data[128] = {
        0x86, 0x3a, 0x60, 0x8f, 0xdc, 0x3b, 0x39, 0x65, 0xa8, 0x0a, 0x82, 0x27, 0x43, 0x9b, 0xa5,
        0x6c, 0xa0, 0x4b, 0x0e, 0x7e, 0xce, 0x83, 0x2b, 0x29, 0xa5, 0x88, 0x80, 0xcf, 0x8d, 0x08,
        0x27, 0x5a, 0xef, 0xb1, 0x21, 0xd3, 0xb7, 0xec, 0x96, 0xc3, 0xce, 0x5c, 0x1b, 0x63, 0xd1,
        0x98, 0xd3, 0x39, 0x72, 0x06, 0xd7, 0xa0, 0x81, 0x85, 0x14, 0x8d, 0xe4, 0x46, 0x8d, 0x11,
        0x3e, 0xc8, 0xd9, 0x38, 0xf2, 0xeb, 0x8e, 0xb6, 0x05, 0x6f, 0x99, 0xca, 0x32, 0x50, 0x12,
        0xe3, 0xbc, 0xc5, 0xaf, 0x27, 0x08, 0x2b, 0xec, 0xd8, 0xb6, 0x3d, 0xaf, 0x37, 0x41, 0x2f,
        0x94, 0x1b, 0xac, 0x08, 0x99, 0x30, 0xe4, 0xc0, 0xd9, 0x01, 0xdf, 0xc6, 0xb3, 0xda, 0x87,
        0x02, 0x9f, 0xda, 0x4d, 0x3b, 0x25, 0x8d, 0xcc, 0xb8, 0x0b, 0x96, 0x2e, 0x03, 0x50, 0xec,
        0xbd, 0x51, 0x7f, 0x28, 0xda, 0xb6, 0xdd, 0x09};

    const alt_u8 test_pubkey_cx[SHA256_LENGTH] = {
        0x94, 0x2c, 0x9f, 0x40, 0x8e, 0xad, 0x9d, 0x82, 0xd3, 0x4a, 0x1b,
        0x9a, 0x6a, 0x82, 0x7e, 0xbe, 0x3e, 0x2d, 0xdf, 0x78, 0x2b, 0x44,
        0x8d, 0x23, 0xbe, 0x1b, 0x61, 0x43, 0x98, 0x8c, 0xce, 0xf4};

    const alt_u8 test_pubkey_cy[SHA256_LENGTH] = {
        0x8c, 0x9e, 0xaf, 0x6c, 0x0d, 0x14, 0xd9, 0x92, 0xfc, 0x63, 0xba,
        0xd3, 0xe2, 0x49, 0x6b, 0xe2, 0xee, 0xe6, 0x1c, 0xb5, 0xb9, 0x7f,
        0x65, 0xf4, 0x28, 0xca, 0x94, 0xa5, 0xd0, 0xee, 0x19, 0xa1};

    const alt_u8 test_sig_r[SHA256_LENGTH] = {0x6b, 0xd9, 0x60, 0x6b, 0xff, 0x81, 0x42, 0xc6,
                                                  0x67, 0x53, 0x16, 0x04, 0xe1, 0x5a, 0xa0, 0x39,
                                                  0x11, 0x47, 0x45, 0x14, 0xdf, 0xdf, 0xdf, 0x84,
                                                  0xeb, 0xeb, 0x2d, 0xa8, 0x57, 0xc8, 0x33, 0x77};

    const alt_u8 test_sig_s[SHA256_LENGTH] = {0x4f, 0xd4, 0x6c, 0x71, 0x18, 0x3c, 0x2b, 0xb7,
                                                  0xca, 0x47, 0x03, 0x0c, 0xee, 0x81, 0xe2, 0xee,
                                                  0xc9, 0xe3, 0x17, 0xb9, 0x12, 0x24, 0x33, 0x25,
                                                  0xf2, 0x73, 0x85, 0x5a, 0x66, 0xc7, 0x6d, 0x5e};

    EXPECT_EQ(alt_u32(1),
              verify_ecdsa_and_sha((alt_u32*) test_pubkey_cx,
                                   (alt_u32*) test_pubkey_cy,
                                   (alt_u32*) test_sig_r,
                                   (alt_u32*) test_sig_s,
								   0,
                                   (alt_u32*) test_data,
                                   test_data_size,
                                   CRYPTO_256_MODE,
								   DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_multiple_block_pattern_sha_and_ec)
{
/*
	--------------------------------------------------------------------------------
	INFO: Preparing to generate 1 patterns of 4 blocks
	--------------------------------------------------------------------------------
	Generating pattern 0 of 512 bytes (4096 bits)
	Test Data block 0: 1024'h6B08AFF2A0BD5DE59734BC5996BCCAF0BF412FA57F8F78F32CB9CA366FC94120E4ACDABF249A1370162993C747865FBB593374D8FF528BD4306A1A34D21AF41D680EB8AFB8EBB54E4AFD6727B1099BF4627260680338771A70BFFA5F3D077897C7E5CCEC03FD6C8C8E4ED48221ADE02804C840203CD7AA6B2E3F7B4AF4E73D28
	Test Data block 1: 1024'h42960729AB6FFC126448471C4BD8A11FDF89F6D99D5C50A2365EFE7F888C22F15B3B622A395FAA9297EF93EAE134439C77776A1035A8FB705498434C843BA7F40654F201F7995B75F100E4ED42BEC4A3449D4AF3A922602DF51B25563811052ECD9728221976E39748B6EECB4BAE1B7AD94BC7065C538CB897920B6AE6133568
	Test Data block 2: 1024'hDF8B1213D09A25B7AD339A53814C74B327E3FF2B71A15ACE4AAB5BCD72EA80ED19B960CBBA363CAFF77E0FECE090E162B5916A62EF0838EB8AF8E0D28C6D09B71D2E40F25360E67DD5F5922D3B33169CE1B15D205F2C5A82912E385DB1A2531AD46A3233F13075A1C53A954388B4769DF191C94FD4E73AA10972CDD098739BB5
	Test Data block 3: 1024'h17CC98378D4F52418DC225E2B41F11C5212FFA3874495BFC73167054D909561CB78BE24AC4FF76632A0B4E84C0162B1C84B51C56A8A85C9AFF6F82DD69C2D1B257C06C9D2C1496E3E530586A510B95E5FB4D052AF8D2BC4EBC19FA90429D1AC6B9E2FE67606310B5DF2FF22448C8BADDB88A83B0C7F6F0F7BDDFFE20E44EA198
	Total Test data : 4096'h6B08AFF2A0BD5DE59734BC5996BCCAF0BF412FA57F8F78F32CB9CA366FC94120E4ACDABF249A1370162993C747865FBB593374D8FF528BD4306A1A34D21AF41D680EB8AFB8EBB54E4AFD6727B1099BF4627260680338771A70BFFA5F3D077897C7E5CCEC03FD6C8C8E4ED48221ADE02804C840203CD7AA6B2E3F7B4AF4E73D2842960729AB6FFC126448471C4BD8A11FDF89F6D99D5C50A2365EFE7F888C22F15B3B622A395FAA9297EF93EAE134439C77776A1035A8FB705498434C843BA7F40654F201F7995B75F100E4ED42BEC4A3449D4AF3A922602DF51B25563811052ECD9728221976E39748B6EECB4BAE1B7AD94BC7065C538CB897920B6AE6133568DF8B1213D09A25B7AD339A53814C74B327E3FF2B71A15ACE4AAB5BCD72EA80ED19B960CBBA363CAFF77E0FECE090E162B5916A62EF0838EB8AF8E0D28C6D09B71D2E40F25360E67DD5F5922D3B33169CE1B15D205F2C5A82912E385DB1A2531AD46A3233F13075A1C53A954388B4769DF191C94FD4E73AA10972CDD098739BB517CC98378D4F52418DC225E2B41F11C5212FFA3874495BFC73167054D909561CB78BE24AC4FF76632A0B4E84C0162B1C84B51C56A8A85C9AFF6F82DD69C2D1B257C06C9D2C1496E3E530586A510B95E5FB4D052AF8D2BC4EBC19FA90429D1AC6B9E2FE67606310B5DF2FF22448C8BADDB88A83B0C7F6F0F7BDDFFE20E44EA198
	Digest : 256'h90068069A1169F084DD6A299EF1FCC18F1E321638958C20D5A88E96B9DF4814E
	Generating curve
	Using curve prime256v1
	Generating private key
	Private Key:
	                256'hBE342FD62FF399A63888D6DF181309C0630C925290AE0E2C5715E6DDF30FBD7E
	Pubkey:
	        CX : 256'hF1EBC4BADF43B9127E9C731EA6A783CA78A16D7DE05BD78E4DB11D814CB4DEF7
	        CY : 256'hB3EBD639EB7B31794F3DF055DE8A0F2C4FF3FC98E5505148CA9B0BF6C22F57F1
	Hash:
	        E :  256'h90068069A1169F084DD6A299EF1FCC18F1E321638958C20D5A88E96B9DF4814E
	Signature:
	        R :  256'hF84AB0EAC7E1CE220EDF9F5CAF295D3616E00A8A54F7AF004D840A40E745B9F4
	        S :  256'h54780292753AC7EBCD1F5357BA181CAF99376DD1708789C288E9699189CBE96A

*/

	const alt_u32 test_data_size = 512;

	const alt_u8 test_data[512] = {
			  0x6b, 0x08, 0xaf, 0xf2, 0xa0, 0xbd, 0x5d, 0xe5, 0x97, 0x34, 0xbc, 0x59,
			  0x96, 0xbc, 0xca, 0xf0, 0xbf, 0x41, 0x2f, 0xa5, 0x7f, 0x8f, 0x78, 0xf3,
			  0x2c, 0xb9, 0xca, 0x36, 0x6f, 0xc9, 0x41, 0x20, 0xe4, 0xac, 0xda, 0xbf,
			  0x24, 0x9a, 0x13, 0x70, 0x16, 0x29, 0x93, 0xc7, 0x47, 0x86, 0x5f, 0xbb,
			  0x59, 0x33, 0x74, 0xd8, 0xff, 0x52, 0x8b, 0xd4, 0x30, 0x6a, 0x1a, 0x34,
			  0xd2, 0x1a, 0xf4, 0x1d, 0x68, 0x0e, 0xb8, 0xaf, 0xb8, 0xeb, 0xb5, 0x4e,
			  0x4a, 0xfd, 0x67, 0x27, 0xb1, 0x09, 0x9b, 0xf4, 0x62, 0x72, 0x60, 0x68,
			  0x03, 0x38, 0x77, 0x1a, 0x70, 0xbf, 0xfa, 0x5f, 0x3d, 0x07, 0x78, 0x97,
			  0xc7, 0xe5, 0xcc, 0xec, 0x03, 0xfd, 0x6c, 0x8c, 0x8e, 0x4e, 0xd4, 0x82,
			  0x21, 0xad, 0xe0, 0x28, 0x04, 0xc8, 0x40, 0x20, 0x3c, 0xd7, 0xaa, 0x6b,
			  0x2e, 0x3f, 0x7b, 0x4a, 0xf4, 0xe7, 0x3d, 0x28,
			  0x42, 0x96, 0x07, 0x29, 0xab, 0x6f, 0xfc, 0x12, 0x64, 0x48, 0x47, 0x1c,
			  0x4b, 0xd8, 0xa1, 0x1f, 0xdf, 0x89, 0xf6, 0xd9, 0x9d, 0x5c, 0x50, 0xa2,
			  0x36, 0x5e, 0xfe, 0x7f, 0x88, 0x8c, 0x22, 0xf1, 0x5b, 0x3b, 0x62, 0x2a,
			  0x39, 0x5f, 0xaa, 0x92, 0x97, 0xef, 0x93, 0xea, 0xe1, 0x34, 0x43, 0x9c,
			  0x77, 0x77, 0x6a, 0x10, 0x35, 0xa8, 0xfb, 0x70, 0x54, 0x98, 0x43, 0x4c,
			  0x84, 0x3b, 0xa7, 0xf4, 0x06, 0x54, 0xf2, 0x01, 0xf7, 0x99, 0x5b, 0x75,
			  0xf1, 0x00, 0xe4, 0xed, 0x42, 0xbe, 0xc4, 0xa3, 0x44, 0x9d, 0x4a, 0xf3,
			  0xa9, 0x22, 0x60, 0x2d, 0xf5, 0x1b, 0x25, 0x56, 0x38, 0x11, 0x05, 0x2e,
			  0xcd, 0x97, 0x28, 0x22, 0x19, 0x76, 0xe3, 0x97, 0x48, 0xb6, 0xee, 0xcb,
			  0x4b, 0xae, 0x1b, 0x7a, 0xd9, 0x4b, 0xc7, 0x06, 0x5c, 0x53, 0x8c, 0xb8,
			  0x97, 0x92, 0x0b, 0x6a, 0xe6, 0x13, 0x35, 0x68,
			  0xdf, 0x8b, 0x12, 0x13, 0xd0, 0x9a, 0x25, 0xb7, 0xad, 0x33, 0x9a, 0x53,
			  0x81, 0x4c, 0x74, 0xb3, 0x27, 0xe3, 0xff, 0x2b, 0x71, 0xa1, 0x5a, 0xce,
			  0x4a, 0xab, 0x5b, 0xcd, 0x72, 0xea, 0x80, 0xed, 0x19, 0xb9, 0x60, 0xcb,
			  0xba, 0x36, 0x3c, 0xaf, 0xf7, 0x7e, 0x0f, 0xec, 0xe0, 0x90, 0xe1, 0x62,
			  0xb5, 0x91, 0x6a, 0x62, 0xef, 0x08, 0x38, 0xeb, 0x8a, 0xf8, 0xe0, 0xd2,
			  0x8c, 0x6d, 0x09, 0xb7, 0x1d, 0x2e, 0x40, 0xf2, 0x53, 0x60, 0xe6, 0x7d,
			  0xd5, 0xf5, 0x92, 0x2d, 0x3b, 0x33, 0x16, 0x9c, 0xe1, 0xb1, 0x5d, 0x20,
			  0x5f, 0x2c, 0x5a, 0x82, 0x91, 0x2e, 0x38, 0x5d, 0xb1, 0xa2, 0x53, 0x1a,
			  0xd4, 0x6a, 0x32, 0x33, 0xf1, 0x30, 0x75, 0xa1, 0xc5, 0x3a, 0x95, 0x43,
			  0x88, 0xb4, 0x76, 0x9d, 0xf1, 0x91, 0xc9, 0x4f, 0xd4, 0xe7, 0x3a, 0xa1,
			  0x09, 0x72, 0xcd, 0xd0, 0x98, 0x73, 0x9b, 0xb5,
			  0x17, 0xcc, 0x98, 0x37, 0x8d, 0x4f, 0x52, 0x41, 0x8d, 0xc2, 0x25, 0xe2,
			  0xb4, 0x1f, 0x11, 0xc5, 0x21, 0x2f, 0xfa, 0x38, 0x74, 0x49, 0x5b, 0xfc,
			  0x73, 0x16, 0x70, 0x54, 0xd9, 0x09, 0x56, 0x1c, 0xb7, 0x8b, 0xe2, 0x4a,
			  0xc4, 0xff, 0x76, 0x63, 0x2a, 0x0b, 0x4e, 0x84, 0xc0, 0x16, 0x2b, 0x1c,
			  0x84, 0xb5, 0x1c, 0x56, 0xa8, 0xa8, 0x5c, 0x9a, 0xff, 0x6f, 0x82, 0xdd,
			  0x69, 0xc2, 0xd1, 0xb2, 0x57, 0xc0, 0x6c, 0x9d, 0x2c, 0x14, 0x96, 0xe3,
			  0xe5, 0x30, 0x58, 0x6a, 0x51, 0x0b, 0x95, 0xe5, 0xfb, 0x4d, 0x05, 0x2a,
			  0xf8, 0xd2, 0xbc, 0x4e, 0xbc, 0x19, 0xfa, 0x90, 0x42, 0x9d, 0x1a, 0xc6,
			  0xb9, 0xe2, 0xfe, 0x67, 0x60, 0x63, 0x10, 0xb5, 0xdf, 0x2f, 0xf2, 0x24,
			  0x48, 0xc8, 0xba, 0xdd, 0xb8, 0x8a, 0x83, 0xb0, 0xc7, 0xf6, 0xf0, 0xf7,
			  0xbd, 0xdf, 0xfe, 0x20, 0xe4, 0x4e, 0xa1, 0x98
	};

	const alt_u8 expected_hash[SHA256_LENGTH] = {
			  0x90, 0x06, 0x80, 0x69, 0xa1, 0x16, 0x9f, 0x08, 0x4d, 0xd6, 0xa2, 0x99,
			  0xef, 0x1f, 0xcc, 0x18, 0xf1, 0xe3, 0x21, 0x63, 0x89, 0x58, 0xc2, 0x0d,
			  0x5a, 0x88, 0xe9, 0x6b, 0x9d, 0xf4, 0x81, 0x4e
	};

	const alt_u8 test_pubkey_cx[SHA256_LENGTH] = {
			  0xf1, 0xeb, 0xc4, 0xba, 0xdf, 0x43, 0xb9, 0x12, 0x7e, 0x9c, 0x73, 0x1e,
			  0xa6, 0xa7, 0x83, 0xca, 0x78, 0xa1, 0x6d, 0x7d, 0xe0, 0x5b, 0xd7, 0x8e,
			  0x4d, 0xb1, 0x1d, 0x81, 0x4c, 0xb4, 0xde, 0xf7
	};

	const alt_u8 test_pubkey_cy[SHA256_LENGTH] = {
			  0xb3, 0xeb, 0xd6, 0x39, 0xeb, 0x7b, 0x31, 0x79, 0x4f, 0x3d, 0xf0, 0x55,
			  0xde, 0x8a, 0x0f, 0x2c, 0x4f, 0xf3, 0xfc, 0x98, 0xe5, 0x50, 0x51, 0x48,
			  0xca, 0x9b, 0x0b, 0xf6, 0xc2, 0x2f, 0x57, 0xf1
	};

	const alt_u8 test_sig_r[SHA256_LENGTH] = {
			  0xf8, 0x4a, 0xb0, 0xea, 0xc7, 0xe1, 0xce, 0x22, 0x0e, 0xdf, 0x9f, 0x5c,
			  0xaf, 0x29, 0x5d, 0x36, 0x16, 0xe0, 0x0a, 0x8a, 0x54, 0xf7, 0xaf, 0x00,
			  0x4d, 0x84, 0x0a, 0x40, 0xe7, 0x45, 0xb9, 0xf4

	};

	const alt_u8 test_sig_s[SHA256_LENGTH] = {
			  0x54, 0x78, 0x02, 0x92, 0x75, 0x3a, 0xc7, 0xeb, 0xcd, 0x1f, 0x53, 0x57,
			  0xba, 0x18, 0x1c, 0xaf, 0x99, 0x37, 0x6d, 0xd1, 0x70, 0x87, 0x89, 0xc2,
			  0x88, 0xe9, 0x69, 0x91, 0x89, 0xcb, 0xe9, 0x6a
	};

    alt_u32* td_crypto_data_ptr = (alt_u32*) test_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, test_data_size, CRYPTO_256_MODE, DISENGAGE_DMA));

    EXPECT_EQ(alt_u32(1),
              verify_ecdsa_and_sha((alt_u32*) test_pubkey_cx,
                                   (alt_u32*) test_pubkey_cy,
                                   (alt_u32*) test_sig_r,
                                   (alt_u32*) test_sig_s,
								   0,
                                   (alt_u32*) test_data,
                                   test_data_size,
                                   CRYPTO_256_MODE,
								   DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_dma_execution_spi)
{
    // This unit test loads the BMC SPI Flash image into SPI FLash Mock Memory space.
    // The difference on this unit test is that the DMA is doing the padding of the data instead of NIOS
    // Prepare SPI flash
    SYSTEM_MOCK::get()->load_to_flash(SPI_FLASH_BMC, FULL_PFR_IMAGE_BMC_FILE, FULL_PFR_IMAGE_BMC_FILE_SIZE);
    // Perform provisioning
    SYSTEM_MOCK::get()->provision_ufm_data(UFM_PFR_DATA_EXAMPLE_KEY_FILE);

    switch_spi_flash(SPI_FLASH_BMC);
    alt_u32* bmc_spi_flash_ptr = get_spi_flash_ptr();

    // Start the DMA execution by using this function.
    alt_u8 expected_hash[FULL_PFR_IMAGE_BMC_FILE_HASH_SIZE] = FULL_PFR_IMAGE_BMC_FILE_HASH;
    EXPECT_TRUE(verify_sha((alt_u32*) expected_hash, 0, bmc_spi_flash_ptr, FULL_PFR_IMAGE_BMC_FILE_SIZE, CRYPTO_256_MODE, ENGAGE_DMA_SPI));
}

TEST_F(PFRCryptoTest, test_dma_execution_ufm)
{
    // This unit test loads the cpld image into UFM FLash Mock Memory space.
    // The difference on this unit test is that the DMA is doing the padding of the data instead of NIOS
    // Load active CPLD image to UFM
    SYSTEM_MOCK::get()->init_x86_mem_from_file(CFM1_ACTIVE_IMAGE_FILE, UFM_MOCK::get()->get_flash_ptr());

    alt_u32* ufm_flash_ptr = UFM_MOCK::get()->get_flash_ptr();

    // Start the DMA execution by using this function.
    alt_u8 cfm1_hash[CFM1_ACTIVE_IMAGE_FILE_HASH_SIZE] = CFM1_ACTIVE_IMAGE_FILE_HASH;
    EXPECT_TRUE(verify_sha((alt_u32*) cfm1_hash, 0, ufm_flash_ptr, CFM1_ACTIVE_IMAGE_FILE_SIZE, CRYPTO_256_MODE, ENGAGE_DMA_UFM));
}

TEST_F(PFRCryptoTest, test_generate_pubkey)
{
	const alt_u32 test_data_size = 512;

	const alt_u8 test_data[512] = {
			  0x6b, 0x08, 0xaf, 0xf2, 0xa0, 0xbd, 0x5d, 0xe5, 0x97, 0x34, 0xbc, 0x59,
			  0x96, 0xbc, 0xca, 0xf0, 0xbf, 0x41, 0x2f, 0xa5, 0x7f, 0x8f, 0x78, 0xf3,
			  0x2c, 0xb9, 0xca, 0x36, 0x6f, 0xc9, 0x41, 0x20, 0xe4, 0xac, 0xda, 0xbf,
			  0x24, 0x9a, 0x13, 0x70, 0x16, 0x29, 0x93, 0xc7, 0x47, 0x86, 0x5f, 0xbb,
			  0x59, 0x33, 0x74, 0xd8, 0xff, 0x52, 0x8b, 0xd4, 0x30, 0x6a, 0x1a, 0x34,
			  0xd2, 0x1a, 0xf4, 0x1d, 0x68, 0x0e, 0xb8, 0xaf, 0xb8, 0xeb, 0xb5, 0x4e,
			  0x4a, 0xfd, 0x67, 0x27, 0xb1, 0x09, 0x9b, 0xf4, 0x62, 0x72, 0x60, 0x68,
			  0x03, 0x38, 0x77, 0x1a, 0x70, 0xbf, 0xfa, 0x5f, 0x3d, 0x07, 0x78, 0x97,
			  0xc7, 0xe5, 0xcc, 0xec, 0x03, 0xfd, 0x6c, 0x8c, 0x8e, 0x4e, 0xd4, 0x82,
			  0x21, 0xad, 0xe0, 0x28, 0x04, 0xc8, 0x40, 0x20, 0x3c, 0xd7, 0xaa, 0x6b,
			  0x2e, 0x3f, 0x7b, 0x4a, 0xf4, 0xe7, 0x3d, 0x28,
			  0x42, 0x96, 0x07, 0x29, 0xab, 0x6f, 0xfc, 0x12, 0x64, 0x48, 0x47, 0x1c,
			  0x4b, 0xd8, 0xa1, 0x1f, 0xdf, 0x89, 0xf6, 0xd9, 0x9d, 0x5c, 0x50, 0xa2,
			  0x36, 0x5e, 0xfe, 0x7f, 0x88, 0x8c, 0x22, 0xf1, 0x5b, 0x3b, 0x62, 0x2a,
			  0x39, 0x5f, 0xaa, 0x92, 0x97, 0xef, 0x93, 0xea, 0xe1, 0x34, 0x43, 0x9c,
			  0x77, 0x77, 0x6a, 0x10, 0x35, 0xa8, 0xfb, 0x70, 0x54, 0x98, 0x43, 0x4c,
			  0x84, 0x3b, 0xa7, 0xf4, 0x06, 0x54, 0xf2, 0x01, 0xf7, 0x99, 0x5b, 0x75,
			  0xf1, 0x00, 0xe4, 0xed, 0x42, 0xbe, 0xc4, 0xa3, 0x44, 0x9d, 0x4a, 0xf3,
			  0xa9, 0x22, 0x60, 0x2d, 0xf5, 0x1b, 0x25, 0x56, 0x38, 0x11, 0x05, 0x2e,
			  0xcd, 0x97, 0x28, 0x22, 0x19, 0x76, 0xe3, 0x97, 0x48, 0xb6, 0xee, 0xcb,
			  0x4b, 0xae, 0x1b, 0x7a, 0xd9, 0x4b, 0xc7, 0x06, 0x5c, 0x53, 0x8c, 0xb8,
			  0x97, 0x92, 0x0b, 0x6a, 0xe6, 0x13, 0x35, 0x68,
			  0xdf, 0x8b, 0x12, 0x13, 0xd0, 0x9a, 0x25, 0xb7, 0xad, 0x33, 0x9a, 0x53,
			  0x81, 0x4c, 0x74, 0xb3, 0x27, 0xe3, 0xff, 0x2b, 0x71, 0xa1, 0x5a, 0xce,
			  0x4a, 0xab, 0x5b, 0xcd, 0x72, 0xea, 0x80, 0xed, 0x19, 0xb9, 0x60, 0xcb,
			  0xba, 0x36, 0x3c, 0xaf, 0xf7, 0x7e, 0x0f, 0xec, 0xe0, 0x90, 0xe1, 0x62,
			  0xb5, 0x91, 0x6a, 0x62, 0xef, 0x08, 0x38, 0xeb, 0x8a, 0xf8, 0xe0, 0xd2,
			  0x8c, 0x6d, 0x09, 0xb7, 0x1d, 0x2e, 0x40, 0xf2, 0x53, 0x60, 0xe6, 0x7d,
			  0xd5, 0xf5, 0x92, 0x2d, 0x3b, 0x33, 0x16, 0x9c, 0xe1, 0xb1, 0x5d, 0x20,
			  0x5f, 0x2c, 0x5a, 0x82, 0x91, 0x2e, 0x38, 0x5d, 0xb1, 0xa2, 0x53, 0x1a,
			  0xd4, 0x6a, 0x32, 0x33, 0xf1, 0x30, 0x75, 0xa1, 0xc5, 0x3a, 0x95, 0x43,
			  0x88, 0xb4, 0x76, 0x9d, 0xf1, 0x91, 0xc9, 0x4f, 0xd4, 0xe7, 0x3a, 0xa1,
			  0x09, 0x72, 0xcd, 0xd0, 0x98, 0x73, 0x9b, 0xb5,
			  0x17, 0xcc, 0x98, 0x37, 0x8d, 0x4f, 0x52, 0x41, 0x8d, 0xc2, 0x25, 0xe2,
			  0xb4, 0x1f, 0x11, 0xc5, 0x21, 0x2f, 0xfa, 0x38, 0x74, 0x49, 0x5b, 0xfc,
			  0x73, 0x16, 0x70, 0x54, 0xd9, 0x09, 0x56, 0x1c, 0xb7, 0x8b, 0xe2, 0x4a,
			  0xc4, 0xff, 0x76, 0x63, 0x2a, 0x0b, 0x4e, 0x84, 0xc0, 0x16, 0x2b, 0x1c,
			  0x84, 0xb5, 0x1c, 0x56, 0xa8, 0xa8, 0x5c, 0x9a, 0xff, 0x6f, 0x82, 0xdd,
			  0x69, 0xc2, 0xd1, 0xb2, 0x57, 0xc0, 0x6c, 0x9d, 0x2c, 0x14, 0x96, 0xe3,
			  0xe5, 0x30, 0x58, 0x6a, 0x51, 0x0b, 0x95, 0xe5, 0xfb, 0x4d, 0x05, 0x2a,
			  0xf8, 0xd2, 0xbc, 0x4e, 0xbc, 0x19, 0xfa, 0x90, 0x42, 0x9d, 0x1a, 0xc6,
			  0xb9, 0xe2, 0xfe, 0x67, 0x60, 0x63, 0x10, 0xb5, 0xdf, 0x2f, 0xf2, 0x24,
			  0x48, 0xc8, 0xba, 0xdd, 0xb8, 0x8a, 0x83, 0xb0, 0xc7, 0xf6, 0xf0, 0xf7,
			  0xbd, 0xdf, 0xfe, 0x20, 0xe4, 0x4e, 0xa1, 0x98
	};

	const alt_u8 expected_hash[SHA256_LENGTH] = {
			  0x90, 0x06, 0x80, 0x69, 0xa1, 0x16, 0x9f, 0x08, 0x4d, 0xd6, 0xa2, 0x99,
			  0xef, 0x1f, 0xcc, 0x18, 0xf1, 0xe3, 0x21, 0x63, 0x89, 0x58, 0xc2, 0x0d,
			  0x5a, 0x88, 0xe9, 0x6b, 0x9d, 0xf4, 0x81, 0x4e
	};

	const alt_u8 test_pubkey_cx[SHA256_LENGTH] = {
			  0xf1, 0xeb, 0xc4, 0xba, 0xdf, 0x43, 0xb9, 0x12, 0x7e, 0x9c, 0x73, 0x1e,
			  0xa6, 0xa7, 0x83, 0xca, 0x78, 0xa1, 0x6d, 0x7d, 0xe0, 0x5b, 0xd7, 0x8e,
			  0x4d, 0xb1, 0x1d, 0x81, 0x4c, 0xb4, 0xde, 0xf7
	};

	const alt_u8 test_pubkey_cy[SHA256_LENGTH] = {
			  0xb3, 0xeb, 0xd6, 0x39, 0xeb, 0x7b, 0x31, 0x79, 0x4f, 0x3d, 0xf0, 0x55,
			  0xde, 0x8a, 0x0f, 0x2c, 0x4f, 0xf3, 0xfc, 0x98, 0xe5, 0x50, 0x51, 0x48,
			  0xca, 0x9b, 0x0b, 0xf6, 0xc2, 0x2f, 0x57, 0xf1
	};

	const alt_u8 test_sig_r[SHA256_LENGTH] = {
			  0xf8, 0x4a, 0xb0, 0xea, 0xc7, 0xe1, 0xce, 0x22, 0x0e, 0xdf, 0x9f, 0x5c,
			  0xaf, 0x29, 0x5d, 0x36, 0x16, 0xe0, 0x0a, 0x8a, 0x54, 0xf7, 0xaf, 0x00,
			  0x4d, 0x84, 0x0a, 0x40, 0xe7, 0x45, 0xb9, 0xf4

	};

	const alt_u8 test_sig_s[SHA256_LENGTH] = {
			  0x54, 0x78, 0x02, 0x92, 0x75, 0x3a, 0xc7, 0xeb, 0xcd, 0x1f, 0x53, 0x57,
			  0xba, 0x18, 0x1c, 0xaf, 0x99, 0x37, 0x6d, 0xd1, 0x70, 0x87, 0x89, 0xc2,
			  0x88, 0xe9, 0x69, 0x91, 0x89, 0xcb, 0xe9, 0x6a
	};

    alt_u32* td_crypto_data_ptr = (alt_u32*) test_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, test_data_size, CRYPTO_256_MODE, DISENGAGE_DMA));

    EXPECT_EQ(alt_u32(1),
              verify_ecdsa_and_sha((alt_u32*) test_pubkey_cx,
                                   (alt_u32*) test_pubkey_cy,
                                   (alt_u32*) test_sig_r,
                                   (alt_u32*) test_sig_s,
								   0,
                                   (alt_u32*) test_data,
                                   test_data_size,
                                   CRYPTO_256_MODE,
								   DISENGAGE_DMA));

    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_256[SHA256_LENGTH] = {
        0xc5, 0x1e, 0x47, 0x53, 0xaf, 0xde, 0xc1, 0xe6, 0xb6, 0xc6, 0xa5, 0xb9, 0x92, 0xf4, 0x3f, 0x8d,
        0xd0, 0xc7, 0xa8, 0x93, 0x30, 0x72, 0x70, 0x8b, 0x65, 0x22, 0x46, 0x8b, 0x2f, 0xfb, 0x06, 0xfd};

    alt_u32 pubkey_cx[8] = {0};
    alt_u32 pubkey_cy[8] = {0};
    // generate_pubkey will return 1 if the created public key matches the expected public key.
    // Bound to change when fw changes.
    EXPECT_EQ(alt_u32(1), generate_pubkey((alt_u32*)pubkey_cx, (alt_u32*)pubkey_cy, (alt_u32*)crypto_ec_da_256, CRYPTO_256_MODE));
}

/**
 * @brief Test check_hmac_validity
 * Four cases where HMAC can be:
 *   1) bigger than ec_n
 *   2) smaller than ec_n
 *   3) equal to ec_n
 *   4) zero
 *
 */
TEST_F(PFRCryptoTest, test_random_data_bigger_than_ec_n)
{
/**************
 * For SHA-256
 **************/
    static const alt_u8 ec_n_256[SHA256_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51};

    static const alt_u8 random_data_all_bytes_big_256[SHA256_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    // Special Test!!!
    static const alt_u32 hidden_random_data_256[SHA256_LENGTH/4] = {
        0xffffffff, 0xfff10ca1, 0xffffcafe, 0xffc0ffee, 0xfffffbad, 0xbce6faad, 0xa7179e84, 0xf3b9cac2};

    static const alt_u8 random_data_lsb_big_256[SHA256_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0xff};

    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)random_data_all_bytes_big_256, (alt_u32*) ec_n_256, CRYPTO_256_MODE));
    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)hidden_random_data_256, (alt_u32*) ec_n_256, CRYPTO_256_MODE));
    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)random_data_lsb_big_256, (alt_u32*) ec_n_256, CRYPTO_256_MODE));
}

/**
 * @brief Test check_hmac_validity
 * Four cases where HMAC can be:
 *   1) bigger than ec_n
 *   2) smaller than ec_n
 *   3) equal to ec_n
 *   4) zero
 *
 */
TEST_F(PFRCryptoTest, test_random_data_smaller_than_ec_n)
{
/**************
 * For SHA-256
 **************/
    static const alt_u8 ec_n_256[SHA256_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51};

    static const alt_u8 random_data_small_bytes_at_msb[SHA256_LENGTH] = {
        0x11, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51};

    static const alt_u8 random_data_small_bytes_in_middle[SHA256_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x0c, 0x0f, 0xfe, 0xe0,
        0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51};

    static const alt_u8 random_data_small_bytes_at_lsb[SHA256_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x01};

    EXPECT_EQ(alt_u32(1), check_hmac_validity((alt_u32*)random_data_small_bytes_at_msb, (alt_u32*) ec_n_256, CRYPTO_256_MODE));
    EXPECT_EQ(alt_u32(1), check_hmac_validity((alt_u32*)random_data_small_bytes_in_middle, (alt_u32*) ec_n_256, CRYPTO_256_MODE));
    EXPECT_EQ(alt_u32(1), check_hmac_validity((alt_u32*)random_data_small_bytes_at_lsb, (alt_u32*) ec_n_256, CRYPTO_256_MODE));
}

/**
 * @brief Test check_hmac_validity
 * Four cases where HMAC can be:
 *   1) bigger than ec_n
 *   2) smaller than ec_n
 *   3) equal to ec_n
 *   4) zero
 *
 */
TEST_F(PFRCryptoTest, test_random_data_all_zeros)
{
    static const alt_u8 ec_n_256[SHA256_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51};

    static const alt_u8 ec_n_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73};

    static const alt_u8 random_data_256[SHA256_LENGTH] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    static const alt_u8 random_data_384[SHA384_LENGTH] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)random_data_256, (alt_u32*) ec_n_256, CRYPTO_256_MODE));
    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)random_data_384, (alt_u32*) ec_n_384, CRYPTO_384_MODE));
}

/**
 * @brief Test check_hmac_validity
 * Four cases where HMAC can be:
 *   1) bigger than ec_n
 *   2) smaller than ec_n
 *   3) equal to ec_n
 *   4) zero
 *
 */
TEST_F(PFRCryptoTest, test_equal_value_data)
{
    static const alt_u8 ec_n_256[SHA256_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51};

    static const alt_u8 random_data_256[SHA256_LENGTH] = {
    	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    	0xbc, 0xe6, 0xfa, 0xad, 0xa7, 0x17, 0x9e, 0x84, 0xf3, 0xb9, 0xca, 0xc2, 0xfc, 0x63, 0x25, 0x51};

    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)random_data_256, (alt_u32*) ec_n_256, CRYPTO_256_MODE));
}

/**
 * @brief Check if the entropy extractor (mock system) is even random in the first place.
 */
TEST_F(PFRCryptoTest, test_randomization_of_entropy_extractor)
{
    alt_u32 entropy_sample_one[64] = {0};
    alt_u32 entropy_sample_two[64] = {0};
    alt_u32 counter = 0;
    alt_u32 is_random = 1;

    extract_entropy_data((alt_u32*)entropy_sample_one, SHA256_HMAC_ENTROPY);

    std::this_thread::sleep_for(std::chrono::milliseconds(1000));

    extract_entropy_data((alt_u32*)entropy_sample_two, SHA256_HMAC_ENTROPY);

    for (alt_u32 i = 0; i < SHA256_HMAC_ENTROPY; i++)
    {
    	if (entropy_sample_one[i] == entropy_sample_two[i])
    	{
            counter++;
            if (counter == SHA256_HMAC_ENTROPY)
            {
    		    is_random = 0;
    		    counter = 0;
            }
    	}
    }

    EXPECT_EQ(alt_u32(1), is_random);
}

/**
 * @brief This algorithm is tested by manually computing the HMAC calculation.
 * The HMAC calculation here is done by using openssl function manually.
 * sha256sum and sha384sum is used to compute the hash.
 * These data are manually appended together.
 * The purpose of this test is to make sure firmware is able to reproduce the expected HMAC correctly.
 */
TEST_F(PFRCryptoTest, test_hmac_algorithm_computation_1)
{
	alt_u8 XOR_K0_AND_IPAD_256[CRYPTO_BLOCK_SIZE_FOR_256] = {
			  0xb8, 0xff, 0x6a, 0x2c, 0x63, 0xab, 0x56, 0xbb, 0x0b, 0x80, 0xc9, 0x6d,
			  0xe7, 0x0e, 0xad, 0x41, 0xe5, 0x0a, 0x93, 0x89, 0x08, 0x25, 0xa5, 0x73,
			  0x5e, 0x8e, 0x79, 0x5d, 0xee, 0xc5, 0x43, 0x64, 0x36, 0x36, 0x36, 0x36,
			  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			  0x36, 0x36, 0x36, 0x36};

	alt_u8 XOR_K0_AND_OPAD_256[CRYPTO_BLOCK_SIZE_FOR_256] = {
			  0xd2, 0x95, 0x00, 0x46, 0x09, 0xc1, 0x3c, 0xd1, 0x61, 0xea, 0xa3, 0x07,
			  0x8d, 0x64, 0xc7, 0x2b, 0x8f, 0x60, 0xf9, 0xe3, 0x62, 0x4f, 0xcf, 0x19,
			  0x34, 0xe4, 0x13, 0x37, 0x84, 0xaf, 0x29, 0x0e, 0x5c, 0x5c, 0x5c, 0x5c,
			  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			  0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			  0x5c, 0x5c, 0x5c, 0x5c};

	alt_u8 entropy_sample_output[256];
	std::fill_n(entropy_sample_output, 256, 0xa3);

	alt_u8 expected_precomputed_hmac_256[SHA256_LENGTH] = {
			0x13, 0x18, 0x35, 0xf3, 0xc5, 0x52, 0x6c, 0xdd, 0x2b, 0x6f, 0x6c, 0x04,
			0x49, 0xba, 0x36, 0xf7, 0x15, 0x1d, 0x05, 0x91, 0xe3, 0x3f, 0xf1, 0x06,
			0xa4, 0x7e, 0xd0, 0xee, 0xd7, 0x91, 0x02, 0x4e};

	static alt_u8 hmac_256[SHA256_LENGTH] = {0};

	compute_hmac_algorithm((alt_u32*)hmac_256, (alt_u32*)entropy_sample_output, (alt_u32*)XOR_K0_AND_IPAD_256, (alt_u32*)XOR_K0_AND_OPAD_256, CRYPTO_256_MODE);

	alt_u32 indicator = 1;

	for (alt_u32 i = 0; i < SHA256_LENGTH; i++)
	{
		if (hmac_256[i] != expected_precomputed_hmac_256[i])
		{
			indicator = 0;
		}
	}

	EXPECT_EQ(alt_u32(1), indicator);
}

TEST_F(PFRCryptoTest, test_hmac_algorithm_computation_2)
{
	alt_u8 XOR_K0_AND_IPAD_256[CRYPTO_BLOCK_SIZE_FOR_256] = {
			0x7e, 0xdc, 0xbf, 0xe9, 0x93, 0x2f, 0x77, 0x85, 0x1f, 0x1d, 0xaa, 0xeb,
			0x7e, 0x1c, 0x14, 0xa0, 0x1d, 0x05, 0x68, 0x08, 0xd4, 0x0c, 0x0e, 0x77,
			0x31, 0x2f, 0xd1, 0xd3, 0x45, 0x22, 0x73, 0x30, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36};

	alt_u8 XOR_K0_AND_OPAD_256[CRYPTO_BLOCK_SIZE_FOR_256] = {
			0x40, 0x0d, 0xbd, 0x6c, 0x95, 0xdf, 0xd8, 0xe8, 0x69, 0xc5, 0x2e, 0x6d,
			0x9c, 0xf9, 0x56, 0x04, 0x39, 0x79, 0xfa, 0x72, 0xf5, 0xfa, 0xd7, 0xa3,
			0xe6, 0xb2, 0x18, 0x23, 0x72, 0xd3, 0xb6, 0xfd, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c};

	alt_u8 entropy_sample_output[256];
	std::fill_n(entropy_sample_output, 256, 0xa3);

	alt_u8 expected_precomputed_hmac_256[SHA256_LENGTH] = {
			0x18, 0xc9, 0xfc, 0x34, 0xa3, 0x17, 0xf1, 0x1f, 0x5c, 0x42, 0x1b, 0xc9,
			0xa0, 0xac, 0xea, 0x0c, 0x25, 0xad, 0x01, 0x2f, 0x83, 0x21, 0x61, 0x6b,
			0xc7, 0x2b, 0xbe, 0xab, 0xc8, 0x60, 0xa6, 0x95};

	static alt_u8 hmac_256[SHA256_LENGTH] = {0};

	compute_hmac_algorithm((alt_u32*)hmac_256, (alt_u32*)entropy_sample_output, (alt_u32*)XOR_K0_AND_IPAD_256, (alt_u32*)XOR_K0_AND_OPAD_256, CRYPTO_256_MODE);

	alt_u32 indicator = 1;

	for (alt_u32 i = 0; i < SHA256_LENGTH; i++)
	{
		if (hmac_256[i] != expected_precomputed_hmac_256[i])
		{
			indicator = 0;
		}
	}

	EXPECT_EQ(alt_u32(1), indicator);
}

/**
 * @brief following test uses a different entropy sample output
 */
TEST_F(PFRCryptoTest, test_hmac_algorithm_computation_3)
{
	alt_u8 XOR_K0_AND_IPAD_256[CRYPTO_BLOCK_SIZE_FOR_256] = {
			0x7e, 0xdc, 0xbf, 0xe9, 0x93, 0x2f, 0x77, 0x85, 0x1f, 0x1d, 0xaa, 0xeb,
			0x7e, 0x1c, 0x14, 0xa0, 0x1d, 0x05, 0x68, 0x08, 0xd4, 0x0c, 0x0e, 0x77,
			0x31, 0x2f, 0xd1, 0xd3, 0x45, 0x22, 0x73, 0x30, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36};

	alt_u8 XOR_K0_AND_OPAD_256[CRYPTO_BLOCK_SIZE_FOR_256] = {
			0x40, 0x0d, 0xbd, 0x6c, 0x95, 0xdf, 0xd8, 0xe8, 0x69, 0xc5, 0x2e, 0x6d,
			0x9c, 0xf9, 0x56, 0x04, 0x39, 0x79, 0xfa, 0x72, 0xf5, 0xfa, 0xd7, 0xa3,
			0xe6, 0xb2, 0x18, 0x23, 0x72, 0xd3, 0xb6, 0xfd, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c};

	alt_u8 entropy_sample_output[256];
	std::fill_n(entropy_sample_output, 256, 0x12);

	alt_u8 expected_precomputed_hmac_256[SHA256_LENGTH] = {
			0x78, 0x1c, 0xe0, 0x85, 0xb1, 0xfa, 0x1d, 0x53, 0x67, 0x00, 0xc8, 0x3e,
			0xf2, 0x07, 0xb3, 0xae, 0xa7, 0xb2, 0x07, 0x5a, 0xa8, 0x0f, 0x74, 0x25,
			0x18, 0x9b, 0xa5, 0x99, 0x3e, 0x9d, 0x9a, 0x8d};

	static alt_u8 hmac_256[SHA256_LENGTH] = {0};

	compute_hmac_algorithm((alt_u32*)hmac_256, (alt_u32*)entropy_sample_output, (alt_u32*)XOR_K0_AND_IPAD_256, (alt_u32*)XOR_K0_AND_OPAD_256, CRYPTO_256_MODE);

	alt_u32 indicator = 1;

	for (alt_u32 i = 0; i < SHA256_LENGTH; i++)
	{
		if (hmac_256[i] != expected_precomputed_hmac_256[i])
		{
			indicator = 0;
		}
	}

	EXPECT_EQ(alt_u32(1), indicator);
}

/**
 * @brief Test the generation of ecdsa-256 signature with 64 bytes data
 * and verify this signature.
 */
TEST_F(PFRCryptoTest, test_generate_256_signature_with_64_bytes_data)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_256[SHA256_LENGTH] = {
        0xc5, 0x1e, 0x47, 0x53, 0xaf, 0xde, 0xc1, 0xe6, 0xb6, 0xc6, 0xa5, 0xb9, 0x92, 0xf4, 0x3f, 0x8d,
        0xd0, 0xc7, 0xa8, 0x93, 0x30, 0x72, 0x70, 0x8b, 0x65, 0x22, 0x46, 0x8b, 0x2f, 0xfb, 0x06, 0xfd};

    const alt_u8 crypto_pub_cx_256[SHA256_LENGTH] = {
        0x94, 0x2c, 0x9f, 0x40, 0x8e, 0xad, 0x9d, 0x82, 0xd3, 0x4a, 0x1b, 0x9a, 0x6a, 0x82, 0x7e, 0xbe,
        0x3e, 0x2d, 0xdf, 0x78, 0x2b, 0x44, 0x8d, 0x23, 0xbe, 0x1b, 0x61, 0x43, 0x98, 0x8c, 0xce, 0xf4};

    const alt_u8 crypto_pub_cy_256[SHA256_LENGTH] = {
        0x8c, 0x9e, 0xaf, 0x6c, 0x0d, 0x14, 0xd9, 0x92, 0xfc, 0x63, 0xba, 0xd3, 0xe2, 0x49, 0x6b, 0xe2,
        0xee, 0xe6, 0x1c, 0xb5, 0xb9, 0x7f, 0x65, 0xf4, 0x28, 0xca, 0x94, 0xa5, 0xd0, 0xee, 0x19, 0xa1};

    const alt_u32 test_data_size = 64;

    const alt_u8 test_data[64] = {
        0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
        0x81, 0x17, 0xb7, 0xf6, 0x8d, 0xd8, 0xa3, 0x6c, 0xbf, 0xfa, 0xd0, 0x7d,
        0xde, 0x60, 0x74, 0xc1, 0x65, 0xfa, 0x42, 0x65, 0x49, 0x29, 0x95, 0x1b,
        0xef, 0xb9, 0x83, 0xf0, 0xf6, 0xc1, 0x46, 0xd6, 0x15, 0x73, 0xfa, 0x09,
        0x75, 0xc6, 0x4e, 0x64, 0xf1, 0xde, 0x34, 0x5f, 0x89, 0xf0, 0x61, 0x5d,
        0x61, 0xb4, 0x08, 0x9d};

    alt_u32 sig_r[8] = {0};
    alt_u32 sig_s[8] = {0};

    // Generate the signature using the message and keys and store it.
    generate_ecdsa_signature(sig_r, sig_s, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_ec_da_256, CRYPTO_256_MODE);

    // Verify the generated signature.
    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_pub_cy_256, (const alt_u32*)sig_r, (const alt_u32*)sig_s, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_256_MODE, DISENGAGE_DMA));
}

/**
 * @brief Test the generation of ecdsa-256 signature with 128 bytes data
 * and verify this signature.
 */
TEST_F(PFRCryptoTest, test_generate_256_signature_with_single_sha_block)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_256[SHA256_LENGTH] = {
        0xc5, 0x1e, 0x47, 0x53, 0xaf, 0xde, 0xc1, 0xe6, 0xb6, 0xc6, 0xa5, 0xb9, 0x92, 0xf4, 0x3f, 0x8d,
        0xd0, 0xc7, 0xa8, 0x93, 0x30, 0x72, 0x70, 0x8b, 0x65, 0x22, 0x46, 0x8b, 0x2f, 0xfb, 0x06, 0xfd};

    const alt_u8 crypto_pub_cx_256[SHA256_LENGTH] = {
        0x94, 0x2c, 0x9f, 0x40, 0x8e, 0xad, 0x9d, 0x82, 0xd3, 0x4a, 0x1b, 0x9a, 0x6a, 0x82, 0x7e, 0xbe,
        0x3e, 0x2d, 0xdf, 0x78, 0x2b, 0x44, 0x8d, 0x23, 0xbe, 0x1b, 0x61, 0x43, 0x98, 0x8c, 0xce, 0xf4};

    const alt_u8 crypto_pub_cy_256[SHA256_LENGTH] = {
        0x8c, 0x9e, 0xaf, 0x6c, 0x0d, 0x14, 0xd9, 0x92, 0xfc, 0x63, 0xba, 0xd3, 0xe2, 0x49, 0x6b, 0xe2,
        0xee, 0xe6, 0x1c, 0xb5, 0xb9, 0x7f, 0x65, 0xf4, 0x28, 0xca, 0x94, 0xa5, 0xd0, 0xee, 0x19, 0xa1};

    const alt_u32 test_data_size = 128;

    const alt_u8 test_data[128] = {
        0x86, 0x3a, 0x60, 0x8f, 0xdc, 0x3b, 0x39, 0x65, 0xa8, 0x0a, 0x82, 0x27, 0x43, 0x9b, 0xa5,
        0x6c, 0xa0, 0x4b, 0x0e, 0x7e, 0xce, 0x83, 0x2b, 0x29, 0xa5, 0x88, 0x80, 0xcf, 0x8d, 0x08,
        0x27, 0x5a, 0xef, 0xb1, 0x21, 0xd3, 0xb7, 0xec, 0x96, 0xc3, 0xce, 0x5c, 0x1b, 0x63, 0xd1,
        0x98, 0xd3, 0x39, 0x72, 0x06, 0xd7, 0xa0, 0x81, 0x85, 0x14, 0x8d, 0xe4, 0x46, 0x8d, 0x11,
        0x3e, 0xc8, 0xd9, 0x38, 0xf2, 0xeb, 0x8e, 0xb6, 0x05, 0x6f, 0x99, 0xca, 0x32, 0x50, 0x12,
        0xe3, 0xbc, 0xc5, 0xaf, 0x27, 0x08, 0x2b, 0xec, 0xd8, 0xb6, 0x3d, 0xaf, 0x37, 0x41, 0x2f,
        0x94, 0x1b, 0xac, 0x08, 0x99, 0x30, 0xe4, 0xc0, 0xd9, 0x01, 0xdf, 0xc6, 0xb3, 0xda, 0x87,
        0x02, 0x9f, 0xda, 0x4d, 0x3b, 0x25, 0x8d, 0xcc, 0xb8, 0x0b, 0x96, 0x2e, 0x03, 0x50, 0xec,
        0xbd, 0x51, 0x7f, 0x28, 0xda, 0xb6, 0xdd, 0x09};

    alt_u32 sig_r[8] = {0};
    alt_u32 sig_s[8] = {0};

    generate_ecdsa_signature(sig_r, sig_s, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_ec_da_256, CRYPTO_256_MODE);

    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_pub_cy_256, (const alt_u32*)sig_r, (const alt_u32*)sig_s, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_256_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_generate_256_signature_with_multiple_sha_block)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_256[SHA256_LENGTH] = {
        0xc5, 0x1e, 0x47, 0x53, 0xaf, 0xde, 0xc1, 0xe6, 0xb6, 0xc6, 0xa5, 0xb9, 0x92, 0xf4, 0x3f, 0x8d,
        0xd0, 0xc7, 0xa8, 0x93, 0x30, 0x72, 0x70, 0x8b, 0x65, 0x22, 0x46, 0x8b, 0x2f, 0xfb, 0x06, 0xfd};

    const alt_u8 crypto_pub_cx_256[SHA256_LENGTH] = {
        0x94, 0x2c, 0x9f, 0x40, 0x8e, 0xad, 0x9d, 0x82, 0xd3, 0x4a, 0x1b, 0x9a, 0x6a, 0x82, 0x7e, 0xbe,
        0x3e, 0x2d, 0xdf, 0x78, 0x2b, 0x44, 0x8d, 0x23, 0xbe, 0x1b, 0x61, 0x43, 0x98, 0x8c, 0xce, 0xf4};

    const alt_u8 crypto_pub_cy_256[SHA256_LENGTH] = {
        0x8c, 0x9e, 0xaf, 0x6c, 0x0d, 0x14, 0xd9, 0x92, 0xfc, 0x63, 0xba, 0xd3, 0xe2, 0x49, 0x6b, 0xe2,
        0xee, 0xe6, 0x1c, 0xb5, 0xb9, 0x7f, 0x65, 0xf4, 0x28, 0xca, 0x94, 0xa5, 0xd0, 0xee, 0x19, 0xa1};

	const alt_u32 test_data_size = 512;

	const alt_u8 test_data[512] = {
			  0x6b, 0x08, 0xaf, 0xf2, 0xa0, 0xbd, 0x5d, 0xe5, 0x97, 0x34, 0xbc, 0x59,
			  0x96, 0xbc, 0xca, 0xf0, 0xbf, 0x41, 0x2f, 0xa5, 0x7f, 0x8f, 0x78, 0xf3,
			  0x2c, 0xb9, 0xca, 0x36, 0x6f, 0xc9, 0x41, 0x20, 0xe4, 0xac, 0xda, 0xbf,
			  0x24, 0x9a, 0x13, 0x70, 0x16, 0x29, 0x93, 0xc7, 0x47, 0x86, 0x5f, 0xbb,
			  0x59, 0x33, 0x74, 0xd8, 0xff, 0x52, 0x8b, 0xd4, 0x30, 0x6a, 0x1a, 0x34,
			  0xd2, 0x1a, 0xf4, 0x1d, 0x68, 0x0e, 0xb8, 0xaf, 0xb8, 0xeb, 0xb5, 0x4e,
			  0x4a, 0xfd, 0x67, 0x27, 0xb1, 0x09, 0x9b, 0xf4, 0x62, 0x72, 0x60, 0x68,
			  0x03, 0x38, 0x77, 0x1a, 0x70, 0xbf, 0xfa, 0x5f, 0x3d, 0x07, 0x78, 0x97,
			  0xc7, 0xe5, 0xcc, 0xec, 0x03, 0xfd, 0x6c, 0x8c, 0x8e, 0x4e, 0xd4, 0x82,
			  0x21, 0xad, 0xe0, 0x28, 0x04, 0xc8, 0x40, 0x20, 0x3c, 0xd7, 0xaa, 0x6b,
			  0x2e, 0x3f, 0x7b, 0x4a, 0xf4, 0xe7, 0x3d, 0x28,
			  0x42, 0x96, 0x07, 0x29, 0xab, 0x6f, 0xfc, 0x12, 0x64, 0x48, 0x47, 0x1c,
			  0x4b, 0xd8, 0xa1, 0x1f, 0xdf, 0x89, 0xf6, 0xd9, 0x9d, 0x5c, 0x50, 0xa2,
			  0x36, 0x5e, 0xfe, 0x7f, 0x88, 0x8c, 0x22, 0xf1, 0x5b, 0x3b, 0x62, 0x2a,
			  0x39, 0x5f, 0xaa, 0x92, 0x97, 0xef, 0x93, 0xea, 0xe1, 0x34, 0x43, 0x9c,
			  0x77, 0x77, 0x6a, 0x10, 0x35, 0xa8, 0xfb, 0x70, 0x54, 0x98, 0x43, 0x4c,
			  0x84, 0x3b, 0xa7, 0xf4, 0x06, 0x54, 0xf2, 0x01, 0xf7, 0x99, 0x5b, 0x75,
			  0xf1, 0x00, 0xe4, 0xed, 0x42, 0xbe, 0xc4, 0xa3, 0x44, 0x9d, 0x4a, 0xf3,
			  0xa9, 0x22, 0x60, 0x2d, 0xf5, 0x1b, 0x25, 0x56, 0x38, 0x11, 0x05, 0x2e,
			  0xcd, 0x97, 0x28, 0x22, 0x19, 0x76, 0xe3, 0x97, 0x48, 0xb6, 0xee, 0xcb,
			  0x4b, 0xae, 0x1b, 0x7a, 0xd9, 0x4b, 0xc7, 0x06, 0x5c, 0x53, 0x8c, 0xb8,
			  0x97, 0x92, 0x0b, 0x6a, 0xe6, 0x13, 0x35, 0x68,
			  0xdf, 0x8b, 0x12, 0x13, 0xd0, 0x9a, 0x25, 0xb7, 0xad, 0x33, 0x9a, 0x53,
			  0x81, 0x4c, 0x74, 0xb3, 0x27, 0xe3, 0xff, 0x2b, 0x71, 0xa1, 0x5a, 0xce,
			  0x4a, 0xab, 0x5b, 0xcd, 0x72, 0xea, 0x80, 0xed, 0x19, 0xb9, 0x60, 0xcb,
			  0xba, 0x36, 0x3c, 0xaf, 0xf7, 0x7e, 0x0f, 0xec, 0xe0, 0x90, 0xe1, 0x62,
			  0xb5, 0x91, 0x6a, 0x62, 0xef, 0x08, 0x38, 0xeb, 0x8a, 0xf8, 0xe0, 0xd2,
			  0x8c, 0x6d, 0x09, 0xb7, 0x1d, 0x2e, 0x40, 0xf2, 0x53, 0x60, 0xe6, 0x7d,
			  0xd5, 0xf5, 0x92, 0x2d, 0x3b, 0x33, 0x16, 0x9c, 0xe1, 0xb1, 0x5d, 0x20,
			  0x5f, 0x2c, 0x5a, 0x82, 0x91, 0x2e, 0x38, 0x5d, 0xb1, 0xa2, 0x53, 0x1a,
			  0xd4, 0x6a, 0x32, 0x33, 0xf1, 0x30, 0x75, 0xa1, 0xc5, 0x3a, 0x95, 0x43,
			  0x88, 0xb4, 0x76, 0x9d, 0xf1, 0x91, 0xc9, 0x4f, 0xd4, 0xe7, 0x3a, 0xa1,
			  0x09, 0x72, 0xcd, 0xd0, 0x98, 0x73, 0x9b, 0xb5,
			  0x17, 0xcc, 0x98, 0x37, 0x8d, 0x4f, 0x52, 0x41, 0x8d, 0xc2, 0x25, 0xe2,
			  0xb4, 0x1f, 0x11, 0xc5, 0x21, 0x2f, 0xfa, 0x38, 0x74, 0x49, 0x5b, 0xfc,
			  0x73, 0x16, 0x70, 0x54, 0xd9, 0x09, 0x56, 0x1c, 0xb7, 0x8b, 0xe2, 0x4a,
			  0xc4, 0xff, 0x76, 0x63, 0x2a, 0x0b, 0x4e, 0x84, 0xc0, 0x16, 0x2b, 0x1c,
			  0x84, 0xb5, 0x1c, 0x56, 0xa8, 0xa8, 0x5c, 0x9a, 0xff, 0x6f, 0x82, 0xdd,
			  0x69, 0xc2, 0xd1, 0xb2, 0x57, 0xc0, 0x6c, 0x9d, 0x2c, 0x14, 0x96, 0xe3,
			  0xe5, 0x30, 0x58, 0x6a, 0x51, 0x0b, 0x95, 0xe5, 0xfb, 0x4d, 0x05, 0x2a,
			  0xf8, 0xd2, 0xbc, 0x4e, 0xbc, 0x19, 0xfa, 0x90, 0x42, 0x9d, 0x1a, 0xc6,
			  0xb9, 0xe2, 0xfe, 0x67, 0x60, 0x63, 0x10, 0xb5, 0xdf, 0x2f, 0xf2, 0x24,
			  0x48, 0xc8, 0xba, 0xdd, 0xb8, 0x8a, 0x83, 0xb0, 0xc7, 0xf6, 0xf0, 0xf7,
			  0xbd, 0xdf, 0xfe, 0x20, 0xe4, 0x4e, 0xa1, 0x98
	};

    alt_u32 sig_r[8] = {0};
    alt_u32 sig_s[8] = {0};

    generate_ecdsa_signature(sig_r, sig_s, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_ec_da_256, CRYPTO_256_MODE);

    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_pub_cy_256, (const alt_u32*)sig_r, (const alt_u32*)sig_s, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_256_MODE, DISENGAGE_DMA));
}

/**
 * @brief This test covers the ecdsa public key generation, signature generation
 * with the key components and signature verification for ECDSA-256.
 */
TEST_F(PFRCryptoTest, test_ecdsa_256_flow)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_256[SHA256_LENGTH] = {
        0xc5, 0x1e, 0x47, 0x53, 0xaf, 0xde, 0xc1, 0xe6, 0xb6, 0xc6, 0xa5, 0xb9, 0x92, 0xf4, 0x3f, 0x8d,
        0xd0, 0xc7, 0xa8, 0x93, 0x30, 0x72, 0x70, 0x8b, 0x65, 0x22, 0x46, 0x8b, 0x2f, 0xfb, 0x06, 0xfd};

    alt_u32 crypto_pub_cx_256[SHA256_LENGTH/4] = {0};

    alt_u32 crypto_pub_cy_256[SHA256_LENGTH/4] = {0};

    const alt_u32 test_data_size = 128;

    const alt_u8 test_data[128] = {
        0x86, 0x3a, 0x60, 0x8f, 0xdc, 0x3b, 0x39, 0x65, 0xa8, 0x0a, 0x82, 0x27, 0x43, 0x9b, 0xa5,
        0x6c, 0xa0, 0x4b, 0x0e, 0x7e, 0xce, 0x83, 0x2b, 0x29, 0xa5, 0x88, 0x80, 0xcf, 0x8d, 0x08,
        0x27, 0x5a, 0xef, 0xb1, 0x21, 0xd3, 0xb7, 0xec, 0x96, 0xc3, 0xce, 0x5c, 0x1b, 0x63, 0xd1,
        0x98, 0xd3, 0x39, 0x72, 0x06, 0xd7, 0xa0, 0x81, 0x85, 0x14, 0x8d, 0xe4, 0x46, 0x8d, 0x11,
        0x3e, 0xc8, 0xd9, 0x38, 0xf2, 0xeb, 0x8e, 0xb6, 0x05, 0x6f, 0x99, 0xca, 0x32, 0x50, 0x12,
        0xe3, 0xbc, 0xc5, 0xaf, 0x27, 0x08, 0x2b, 0xec, 0xd8, 0xb6, 0x3d, 0xaf, 0x37, 0x41, 0x2f,
        0x94, 0x1b, 0xac, 0x08, 0x99, 0x30, 0xe4, 0xc0, 0xd9, 0x01, 0xdf, 0xc6, 0xb3, 0xda, 0x87,
        0x02, 0x9f, 0xda, 0x4d, 0x3b, 0x25, 0x8d, 0xcc, 0xb8, 0x0b, 0x96, 0x2e, 0x03, 0x50, 0xec,
        0xbd, 0x51, 0x7f, 0x28, 0xda, 0xb6, 0xdd, 0x09};

    alt_u32 sig_r_1[8] = {0};
    alt_u32 sig_s_1[8] = {0};

    // Generate public keys from priv key
    generate_pubkey((alt_u32*)crypto_pub_cx_256, (alt_u32*)crypto_pub_cy_256, (alt_u32*)crypto_ec_da_256, CRYPTO_256_MODE);

    // Generate signature
    generate_ecdsa_signature(sig_r_1, sig_s_1, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_ec_da_256, CRYPTO_256_MODE);

    // Verify signature
    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_pub_cy_256, (const alt_u32*)sig_r_1, (const alt_u32*)sig_s_1, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_256_MODE, DISENGAGE_DMA));
}

/**
 * @brief This test is to check for the randomness of the signature
 * generated. It is important to have a different signature each time
 * they are generated.
 */
TEST_F(PFRCryptoTest, test_randomness_of_ecdsa_256_signature)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_256[SHA256_LENGTH] = {
        0xc5, 0x1e, 0x47, 0x53, 0xaf, 0xde, 0xc1, 0xe6, 0xb6, 0xc6, 0xa5, 0xb9, 0x92, 0xf4, 0x3f, 0x8d,
        0xd0, 0xc7, 0xa8, 0x93, 0x30, 0x72, 0x70, 0x8b, 0x65, 0x22, 0x46, 0x8b, 0x2f, 0xfb, 0x06, 0xfd};

    const alt_u8 crypto_pub_cx_256[SHA256_LENGTH] = {
        0x94, 0x2c, 0x9f, 0x40, 0x8e, 0xad, 0x9d, 0x82, 0xd3, 0x4a, 0x1b, 0x9a, 0x6a, 0x82, 0x7e, 0xbe,
        0x3e, 0x2d, 0xdf, 0x78, 0x2b, 0x44, 0x8d, 0x23, 0xbe, 0x1b, 0x61, 0x43, 0x98, 0x8c, 0xce, 0xf4};

    const alt_u8 crypto_pub_cy_256[SHA256_LENGTH] = {
        0x8c, 0x9e, 0xaf, 0x6c, 0x0d, 0x14, 0xd9, 0x92, 0xfc, 0x63, 0xba, 0xd3, 0xe2, 0x49, 0x6b, 0xe2,
        0xee, 0xe6, 0x1c, 0xb5, 0xb9, 0x7f, 0x65, 0xf4, 0x28, 0xca, 0x94, 0xa5, 0xd0, 0xee, 0x19, 0xa1};

    const alt_u32 test_data_size = 128;

    const alt_u8 test_data[128] = {
        0x86, 0x3a, 0x60, 0x8f, 0xdc, 0x3b, 0x39, 0x65, 0xa8, 0x0a, 0x82, 0x27, 0x43, 0x9b, 0xa5,
        0x6c, 0xa0, 0x4b, 0x0e, 0x7e, 0xce, 0x83, 0x2b, 0x29, 0xa5, 0x88, 0x80, 0xcf, 0x8d, 0x08,
        0x27, 0x5a, 0xef, 0xb1, 0x21, 0xd3, 0xb7, 0xec, 0x96, 0xc3, 0xce, 0x5c, 0x1b, 0x63, 0xd1,
        0x98, 0xd3, 0x39, 0x72, 0x06, 0xd7, 0xa0, 0x81, 0x85, 0x14, 0x8d, 0xe4, 0x46, 0x8d, 0x11,
        0x3e, 0xc8, 0xd9, 0x38, 0xf2, 0xeb, 0x8e, 0xb6, 0x05, 0x6f, 0x99, 0xca, 0x32, 0x50, 0x12,
        0xe3, 0xbc, 0xc5, 0xaf, 0x27, 0x08, 0x2b, 0xec, 0xd8, 0xb6, 0x3d, 0xaf, 0x37, 0x41, 0x2f,
        0x94, 0x1b, 0xac, 0x08, 0x99, 0x30, 0xe4, 0xc0, 0xd9, 0x01, 0xdf, 0xc6, 0xb3, 0xda, 0x87,
        0x02, 0x9f, 0xda, 0x4d, 0x3b, 0x25, 0x8d, 0xcc, 0xb8, 0x0b, 0x96, 0x2e, 0x03, 0x50, 0xec,
        0xbd, 0x51, 0x7f, 0x28, 0xda, 0xb6, 0xdd, 0x09};

    alt_u32 sig_r_1[8] = {0};
    alt_u32 sig_s_1[8] = {0};
    alt_u32 sig_r_2[8] = {0};
    alt_u32 sig_s_2[8] = {0};
    alt_u32 sig_r_3[8] = {0};
    alt_u32 sig_s_3[8] = {0};

    generate_ecdsa_signature(sig_r_1, sig_s_1, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_ec_da_256, CRYPTO_256_MODE);

    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_pub_cy_256, (const alt_u32*)sig_r_1, (const alt_u32*)sig_s_1, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_256_MODE, DISENGAGE_DMA));

    generate_ecdsa_signature(sig_r_2, sig_s_2, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_ec_da_256, CRYPTO_256_MODE);

    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_pub_cy_256, (const alt_u32*)sig_r_2, (const alt_u32*)sig_s_2, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_256_MODE, DISENGAGE_DMA));

    generate_ecdsa_signature(sig_r_3, sig_s_3, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_ec_da_256, CRYPTO_256_MODE);

    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_256, (const alt_u32*)crypto_pub_cy_256, (const alt_u32*)sig_r_3, (const alt_u32*)sig_s_3, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_256_MODE, DISENGAGE_DMA));

    alt_u32 is_random = 1;

    // Test the randomness of 3 signatures.
    for (alt_u32 i = 0; i < SHA256_LENGTH/4; i++)
    {
        if ((sig_r_1[i] == sig_r_2[i]) || (sig_s_1[i] == sig_s_2[i]) || (sig_r_3[i] == sig_r_2[i]) || (sig_s_3[i] == sig_s_2[i]))
        {
            is_random = 0;
        }
    }

    EXPECT_EQ(alt_u32(1), is_random);
}

/**
 * @brief Force health test failure within entropy
 */
TEST_F(PFRCryptoTest, test_health_circuit_forced_error_of_entropy_extractor)
{
    alt_u32 entropy_sample_one[64] = {0};
    // Force health to fail within the crypto mock
    SYSTEM_MOCK::get()->force_mock_entropy_error();

    // Expect zero for error
    EXPECT_EQ(extract_entropy_data((alt_u32*)entropy_sample_one, SHA256_HMAC_ENTROPY), alt_u32 (0));

    // Expect no written value
    for (alt_u32 i = 0; i < SHA256_HMAC_ENTROPY; i++)
    {
        EXPECT_EQ(entropy_sample_one[i], alt_u32(0));
    }
}
