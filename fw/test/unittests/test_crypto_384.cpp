#include <iostream>
#include <chrono>
#include <openssl/ec.h>
#include <openssl/obj_mac.h>
#include <openssl/bn.h>
#include <openssl/objects.h>
#include <openssl/ecdsa.h>
#include <openssl/evp.h>

// Include the GTest headers
#include "gtest_headers.h"

// Include the SYSTEM MOCK and PFR headers
#include "ut_nios_wrapper.h"

class PFRCryptoTest : public testing::Test
{
public:

/*
    alt_u8 hash_384_ipad_data_1[384] = {
    		0x38, 0x44, 0x50, 0xc1, 0xb6, 0x10, 0x70, 0xca, 0xc5, 0x84, 0x9f, 0x40,
			0x98, 0xdf, 0xe0, 0x0f, 0xb8, 0xff, 0x6a, 0x2c, 0x63, 0xab, 0x56, 0xbb,
			0x0b, 0x80, 0xc9, 0x6d, 0xe7, 0x0e, 0xad, 0x41, 0xe5, 0x0a, 0x93, 0x89,
			0x08, 0x25, 0xa5, 0x73, 0x5e, 0x8e, 0x79, 0x5d, 0xee, 0xc5, 0x43, 0x64,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
			0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
	        0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3,
			0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa3};

    alt_u8 hash_384_ipad_opad_data_2[176] = {
    		0x52, 0x2e, 0x3a, 0xab, 0xdc, 0x7a, 0x1a, 0xa0, 0xaf, 0xee, 0xf5, 0x2a,
			0xf2, 0xb5, 0x8a, 0x65, 0xd2, 0x95, 0x00, 0x46, 0x09, 0xc1, 0x3c, 0xd1,
			0x61, 0xea, 0xa3, 0x07, 0x8d, 0x64, 0xc7, 0x2b, 0x8f, 0x60, 0xf9, 0xe3,
			0x62, 0x4f, 0xcf, 0x19, 0x34, 0xe4, 0x13, 0x37, 0x84, 0xaf, 0x29, 0x0e,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
			0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x23, 0xf2, 0x78, 0x20,
			0xbc, 0x06, 0x12, 0xc6, 0xc3, 0x38, 0xc8, 0x5f, 0x02, 0x57, 0xba, 0x3d,
			0x02, 0xe9, 0xe7, 0x3f, 0x1c, 0x3a, 0x39, 0xe5, 0xef, 0x0f, 0xdf, 0xdb,
			0x85, 0x4a, 0x31, 0x46, 0xb9, 0x24, 0xcf, 0x84, 0x04, 0x47, 0xfc, 0x28,
			0xf0, 0xe8, 0xdb, 0xc4, 0xb6, 0x8c, 0xbd, 0xb9
			};

    alt_u8 hash_256_ipad_data_1[64] = {
  		  0xb8, 0xff, 0x6a, 0x2c, 0x63, 0xab, 0x56, 0xbb, 0x0b, 0x80, 0xc9, 0x6d,
  		  0xe7, 0x0e, 0xad, 0x41, 0xe5, 0x0a, 0x93, 0x89, 0x08, 0x25, 0xa5, 0x73,
  		  0x5e, 0x8e, 0x79, 0x5d, 0xee, 0xc5, 0x43, 0x64, 0x36, 0x36, 0x36, 0x36,
  		  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  		  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  		  0x36, 0x36, 0x36, 0x36};
*/
    /*alt_u8 hash_256_ipad_opad_data_2[254] = {
        	0x13, 0x91, 0x89, 0xca, 0xe6, 0x00, 0x0d, 0xa3, 0xce, 0x06, 0x00, 0xb5,
        	0x2e, 0x0a, 0x36, 0x31, 0xb3, 0x9f, 0xd2, 0x5b, 0x6c, 0x43, 0x1c, 0x07,
        	0x8a, 0x17, 0xf3, 0x64, 0xd6, 0x95, 0x6c, 0x53, 0xd4, 0xd2, 0x4c, 0x77,
        	0x2d, 0x01, 0x3f, 0x87, 0x4d, 0x4c, 0xd0, 0xa2, 0x81, 0x0a, 0xde, 0x59,
        	0x49, 0x44, 0x38, 0xd4, 0xf0, 0x76, 0x7f, 0x6d, 0xcd, 0x90, 0xd6, 0xd0,
        	0xab, 0xac, 0xe3, 0xde, 0x11, 0x38, 0x3e, 0x6f, 0xb7, 0xd2, 0x40, 0x89,
        	0x4d, 0x80, 0x4c, 0x63, 0x2f, 0x3f, 0xc9, 0x9a, 0x26, 0xe0, 0x56, 0x5b,
        	0xf0, 0xf6, 0x59, 0xa1, 0xda, 0xc4, 0xd3, 0x38, 0xd3, 0x3a, 0x30, 0x6f,
        	0x0f, 0xda, 0xe2, 0x27, 0x36, 0xe4, 0xae, 0x50, 0x7f, 0x28, 0xed, 0xc5,
        	0x9c, 0x96, 0x88, 0x90, 0x9b, 0x97, 0xf0, 0xe5, 0x61, 0x0f, 0x6a, 0xa6,
        	0x62, 0x87, 0x3d, 0x9c, 0x6b, 0xe3, 0x21, 0x13, 0x91, 0x89, 0xca, 0xe6,
            0x00, 0x0d, 0xa3, 0xce, 0x06, 0x00, 0xb5,
	    	0x2e, 0x0a, 0x36, 0x31, 0xb3, 0x9f, 0xd2, 0x5b, 0x6c, 0x43, 0x1c, 0x07,
	    	0x8a, 0x17, 0xf3, 0x64, 0xd6, 0x95, 0x6c, 0x53, 0xd4, 0xd2, 0x4c, 0x77,
	    	0x2d, 0x01, 0x3f, 0x87, 0x4d, 0x4c, 0xd0, 0xa2, 0x81, 0x0a, 0xde, 0x59,
	    	0x49, 0x44, 0x38, 0xd4, 0xf0, 0x76, 0x7f, 0x6d, 0xcd, 0x90, 0xd6, 0xd0,
	    	0xab, 0xac, 0xe3, 0xde, 0x11, 0x38, 0x3e, 0x6f, 0xb7, 0xd2, 0x40, 0x89,
	    	0x4d, 0x80, 0x4c, 0x63, 0x2f, 0x3f, 0xc9, 0x9a, 0x26, 0xe0, 0x56, 0x5b,
	    	0xf0, 0xf6, 0x59, 0xa1, 0xda, 0xc4, 0xd3, 0x38, 0xd3, 0x3a, 0x30, 0x6f,
	    	0x0f, 0xda, 0xe2, 0x27, 0x36, 0xe4, 0xae, 0x50, 0x7f, 0x28, 0xed, 0xc5,
	    	0x9c, 0x96, 0x88, 0x90, 0x9b, 0x97, 0xf0, 0xe5, 0x61, 0x0f, 0x6a, 0xa6,
	    	0x62, 0x87, 0x3d, 0x9c, 0x6b, 0xe3, 0x21};*/

    virtual void SetUp() {
        SYSTEM_MOCK::get()->reset();

        //SYSTEM_MOCK::get()->write_x86_mem_to_file("testdata/384_ipad_data.hex", hash_384_ipad_data_1, 384);
        //SYSTEM_MOCK::get()->write_x86_mem_to_file("testdata/256_ipad_data.hex", hash_256_ipad_data_1, 64);
        //SYSTEM_MOCK::get()->write_x86_mem_to_file("testdata/384_opad_ipad_data.hex", hash_384_ipad_opad_data_2, 176);
        //SYSTEM_MOCK::get()->write_x86_mem_to_file("testdata/256_opad_ipad_data.hex", hash_256_ipad_opad_data_2, 254);
}
    virtual void TearDown() {}
};

TEST_F(PFRCryptoTest, test_crypto_block_ready)
{
    // After reset the CSR should be 0
    EXPECT_EQ(IORD(CRYPTO_CSR_ADDR, 0), (alt_u32) 0);

    EXPECT_EQ(IORD(CRYPTO_DATA_ADDR, 0), (alt_u32) 0);

    EXPECT_EQ(IORD(CRYPTO_ENTROPY_SOURCE_OUTPUT_ADDR(0), 0), (alt_u32) 0);

    for (alt_u32 i = 0; i < 12; i++)
    {
        EXPECT_EQ(IORD(CRYPTO_ECDSA_DATA_CX_OUTPUT_ADDR(i), 0), (alt_u32) 0);
        EXPECT_EQ(IORD(CRYPTO_ECDSA_DATA_CY_OUTPUT_ADDR(i), 0), (alt_u32) 0);
        EXPECT_EQ(IORD(CRYPTO_DATA_SHA_ADDR(i), 0), (alt_u32) 0);
    }
}

TEST_F(PFRCryptoTest, test_crypto_mock_read_all_addr)
{
    // Set asserts to throw as opposed to abort
    SYSTEM_MOCK::get()->set_assert_to_throw();

    EXPECT_NO_THROW(IORD(CRYPTO_CSR_ADDR, 0));

    EXPECT_NO_THROW(IORD(CRYPTO_DATA_ADDR, 0));

    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(0), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(1), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(2), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(3), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(4), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(5), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(6), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(7), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(8), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(9), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(10), 0));
    EXPECT_NO_THROW(IORD(CRYPTO_DATA_SHA_ADDR(11), 0));
}


TEST_F(PFRCryptoTest, test_64_bytes_data_sha_only)
{
    const alt_u32 td_sha_data_len = 64;

    const alt_u8 td_crypto_data[64] = {
    		  0xb8, 0xff, 0x6a, 0x2c, 0x63, 0xab, 0x56, 0xbb, 0x0b, 0x80, 0xc9, 0x6d,
    		  0xe7, 0x0e, 0xad, 0x41, 0xe5, 0x0a, 0x93, 0x89, 0x08, 0x25, 0xa5, 0x73,
    		  0x5e, 0x8e, 0x79, 0x5d, 0xee, 0xc5, 0x43, 0x64, 0x36, 0x36, 0x36, 0x36,
    		  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    		  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
    		  0x36, 0x36, 0x36, 0x36
};

    const alt_u8 td_expected_hash[SHA384_LENGTH] = {
    		  0x8c, 0xbc, 0xfd, 0x09, 0x8b, 0x84, 0x7e, 0x9e, 0x28, 0xd7, 0xa1, 0x61,
    		  0x4c, 0x16, 0xf0, 0x57, 0xf0, 0xf0, 0x34, 0x04, 0xb1, 0x03, 0x65, 0x83,
    		  0x30, 0x05, 0x3a, 0x9a, 0xa0, 0xf4, 0xc7, 0xc6, 0x52, 0xf9, 0xa9, 0x8b,
    		  0xf9, 0x5e, 0xe4, 0xe4, 0x83, 0xc7, 0xe2, 0xbf, 0xf9, 0x6a, 0x5d, 0x2e};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_384_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_51_bytes_data_sha_only_unaligned)
{
    const alt_u32 td_sha_data_len = 51;

    const alt_u8 td_crypto_data[51] = {
            0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
            0x81, 0x17, 0xb7, 0xf6, 0x8d, 0xd8, 0xa3, 0x6c, 0xbf, 0xfa, 0xd0, 0x7d,
            0xde, 0x60, 0x74, 0xc1, 0x65, 0xfa, 0x42, 0x65, 0xbf, 0xfa, 0xd0, 0x7d,
            0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
            0xdd, 0xaa, 0xcc
};

    const alt_u8 td_expected_hash[SHA384_LENGTH] = {
        0x85, 0x2d, 0xb3, 0xb6, 0x28, 0xf7, 0x0c, 0x46, 0xb8, 0x26, 0x38, 0xbf,
        0x64, 0x84, 0x8b, 0x05, 0x98, 0xed, 0x6a, 0xea, 0x0c, 0xf2, 0x3e, 0x49,
        0x23, 0x4f, 0xa5, 0xa9, 0xb7, 0xc8, 0x45, 0xc2, 0xf6, 0xea, 0x0b, 0x74,
        0x12, 0xd4, 0x38, 0x88, 0x5e, 0xf9, 0x3c, 0x5f, 0xc1, 0x18, 0xb0, 0xe6};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_384_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_97_bytes_data_sha_only_unaligned)
{
    const alt_u32 td_sha_data_len = 97;

    const alt_u8 td_crypto_data[97] = {
        0x55, 0x05, 0xdf, 0xf8, 0xbd, 0xaa, 0x28, 0x42, 0x85, 0x82, 0x97, 0x88,
    	0x58, 0x28, 0x58, 0x9b, 0x1c, 0xeb, 0x0d, 0xda, 0xe2, 0xf8, 0x4a, 0x3f,
    	0x78, 0xcd, 0x7a, 0x7f, 0x72, 0x9f, 0x25, 0x64, 0x50, 0x9a, 0xdc, 0xdd,
    	0xd1, 0xb4, 0x57, 0xa1, 0xb4, 0xa7, 0x6b, 0x8e, 0x4f, 0x1d, 0xe9, 0xbf,
    	0x5e, 0x46, 0x77, 0xee, 0x95, 0x1b, 0x61, 0xeb, 0xc8, 0x23, 0x32, 0xbe,
    	0x40, 0x1b, 0xa0, 0x36, 0xe5, 0x35, 0xd5, 0xe5, 0xa9, 0x4e, 0x06, 0x81,
    	0x7f, 0x92, 0x96, 0xa6, 0x03, 0xa6, 0x40, 0x36, 0xb1, 0xe9, 0x01, 0xf5,
    	0x51, 0xf4, 0x90, 0x18, 0xf7, 0x61, 0xbb, 0xd2, 0x2c, 0x37, 0x5d, 0xa2,
    	0xaa
};

    const alt_u8 td_expected_hash[SHA384_LENGTH] = {
        0xac, 0x3b, 0xd3, 0xf5, 0x7e, 0x5f, 0xe6, 0x10, 0x0d, 0xb9, 0x50, 0x9b,
        0x05, 0x09, 0xc8, 0xde, 0x83, 0xb3, 0x1f, 0x37, 0xe7, 0xb9, 0x77, 0x60,
        0x17, 0x68, 0xd8, 0xe3, 0x91, 0xd4, 0x66, 0xfd, 0xb8, 0xc6, 0x21, 0x49,
        0x5d, 0x2d, 0xc7, 0xae, 0x9f, 0x00, 0xe1, 0x7f, 0x1b, 0x03, 0x35, 0xd4};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_384_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_127_bytes_data_sha_only_unaligned)
{
    const alt_u32 td_sha_data_len = 127;

    const alt_u8 td_crypto_data[127] = {
    	0x13, 0x91, 0x89, 0xca, 0xe6, 0x00, 0x0d, 0xa3, 0xce, 0x06, 0x00, 0xb5,
    	0x2e, 0x0a, 0x36, 0x31, 0xb3, 0x9f, 0xd2, 0x5b, 0x6c, 0x43, 0x1c, 0x07,
    	0x8a, 0x17, 0xf3, 0x64, 0xd6, 0x95, 0x6c, 0x53, 0xd4, 0xd2, 0x4c, 0x77,
    	0x2d, 0x01, 0x3f, 0x87, 0x4d, 0x4c, 0xd0, 0xa2, 0x81, 0x0a, 0xde, 0x59,
    	0x49, 0x44, 0x38, 0xd4, 0xf0, 0x76, 0x7f, 0x6d, 0xcd, 0x90, 0xd6, 0xd0,
    	0xab, 0xac, 0xe3, 0xde, 0x11, 0x38, 0x3e, 0x6f, 0xb7, 0xd2, 0x40, 0x89,
    	0x4d, 0x80, 0x4c, 0x63, 0x2f, 0x3f, 0xc9, 0x9a, 0x26, 0xe0, 0x56, 0x5b,
    	0xf0, 0xf6, 0x59, 0xa1, 0xda, 0xc4, 0xd3, 0x38, 0xd3, 0x3a, 0x30, 0x6f,
    	0x0f, 0xda, 0xe2, 0x27, 0x36, 0xe4, 0xae, 0x50, 0x7f, 0x28, 0xed, 0xc5,
    	0x9c, 0x96, 0x88, 0x90, 0x9b, 0x97, 0xf0, 0xe5, 0x61, 0x0f, 0x6a, 0xa6,
    	0x62, 0x87, 0x3d, 0x9c, 0x6b, 0xe3, 0x21
};

    const alt_u8 td_expected_hash[SHA384_LENGTH] = {
        0x6a, 0x27, 0xc1, 0x42, 0xa6, 0x4c, 0xaa, 0x98, 0x8a, 0x94, 0xb1, 0x7e,
        0x4a, 0xb4, 0x8d, 0x44, 0xf1, 0xdb, 0x3e, 0x96, 0x1f, 0xa3, 0x75, 0xac,
        0xb3, 0x15, 0x4e, 0x66, 0xe5, 0x2f, 0xbc, 0x85, 0xf7, 0x76, 0x35, 0x3b,
        0x07, 0xd7, 0x77, 0x0c, 0xba, 0x94, 0x49, 0xf0, 0xa2, 0x45, 0x76, 0x05
};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_384_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_254_bytes_data_sha_only_unaligned)
{
    const alt_u32 td_sha_data_len = 254;

    const alt_u8 td_crypto_data[254] = {
    	0x13, 0x91, 0x89, 0xca, 0xe6, 0x00, 0x0d, 0xa3, 0xce, 0x06, 0x00, 0xb5,
    	0x2e, 0x0a, 0x36, 0x31, 0xb3, 0x9f, 0xd2, 0x5b, 0x6c, 0x43, 0x1c, 0x07,
    	0x8a, 0x17, 0xf3, 0x64, 0xd6, 0x95, 0x6c, 0x53, 0xd4, 0xd2, 0x4c, 0x77,
    	0x2d, 0x01, 0x3f, 0x87, 0x4d, 0x4c, 0xd0, 0xa2, 0x81, 0x0a, 0xde, 0x59,
    	0x49, 0x44, 0x38, 0xd4, 0xf0, 0x76, 0x7f, 0x6d, 0xcd, 0x90, 0xd6, 0xd0,
    	0xab, 0xac, 0xe3, 0xde, 0x11, 0x38, 0x3e, 0x6f, 0xb7, 0xd2, 0x40, 0x89,
    	0x4d, 0x80, 0x4c, 0x63, 0x2f, 0x3f, 0xc9, 0x9a, 0x26, 0xe0, 0x56, 0x5b,
    	0xf0, 0xf6, 0x59, 0xa1, 0xda, 0xc4, 0xd3, 0x38, 0xd3, 0x3a, 0x30, 0x6f,
    	0x0f, 0xda, 0xe2, 0x27, 0x36, 0xe4, 0xae, 0x50, 0x7f, 0x28, 0xed, 0xc5,
    	0x9c, 0x96, 0x88, 0x90, 0x9b, 0x97, 0xf0, 0xe5, 0x61, 0x0f, 0x6a, 0xa6,
    	0x62, 0x87, 0x3d, 0x9c, 0x6b, 0xe3, 0x21,
    	0x13, 0x91, 0x89, 0xca, 0xe6, 0x00, 0x0d, 0xa3, 0xce, 0x06, 0x00, 0xb5,
    	0x2e, 0x0a, 0x36, 0x31, 0xb3, 0x9f, 0xd2, 0x5b, 0x6c, 0x43, 0x1c, 0x07,
    	0x8a, 0x17, 0xf3, 0x64, 0xd6, 0x95, 0x6c, 0x53, 0xd4, 0xd2, 0x4c, 0x77,
    	0x2d, 0x01, 0x3f, 0x87, 0x4d, 0x4c, 0xd0, 0xa2, 0x81, 0x0a, 0xde, 0x59,
    	0x49, 0x44, 0x38, 0xd4, 0xf0, 0x76, 0x7f, 0x6d, 0xcd, 0x90, 0xd6, 0xd0,
    	0xab, 0xac, 0xe3, 0xde, 0x11, 0x38, 0x3e, 0x6f, 0xb7, 0xd2, 0x40, 0x89,
    	0x4d, 0x80, 0x4c, 0x63, 0x2f, 0x3f, 0xc9, 0x9a, 0x26, 0xe0, 0x56, 0x5b,
    	0xf0, 0xf6, 0x59, 0xa1, 0xda, 0xc4, 0xd3, 0x38, 0xd3, 0x3a, 0x30, 0x6f,
    	0x0f, 0xda, 0xe2, 0x27, 0x36, 0xe4, 0xae, 0x50, 0x7f, 0x28, 0xed, 0xc5,
    	0x9c, 0x96, 0x88, 0x90, 0x9b, 0x97, 0xf0, 0xe5, 0x61, 0x0f, 0x6a, 0xa6,
    	0x62, 0x87, 0x3d, 0x9c, 0x6b, 0xe3, 0x21
};

    const alt_u8 td_expected_hash[SHA384_LENGTH] = {
        0xb6, 0x28, 0xec, 0x82, 0x87, 0x5e, 0xf0, 0x72, 0x7d, 0x91, 0xba, 0x5d,
        0x97, 0x97, 0x91, 0xc4, 0x4d, 0x6f, 0x3b, 0x20, 0x1d, 0x3d, 0x39, 0x90,
        0xf4, 0x94, 0x63, 0x3b, 0x30, 0x79, 0x79, 0xfc, 0xbc, 0x6a, 0x6b, 0x9b,
        0xde, 0x4e, 0x61, 0xef, 0xa9, 0x86, 0xd6, 0xfb, 0x7f, 0x29, 0x72, 0xfa
};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_384_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_130_bytes_data_sha_only_unaligned)
{
    const alt_u32 td_sha_data_len = 130;

    const alt_u8 td_crypto_data[130] = {
    	0x13, 0x91, 0x89, 0xca, 0xe6, 0x00, 0x0d, 0xa3, 0xce, 0x06, 0x00, 0xb5,
    	0x2e, 0x0a, 0x36, 0x31, 0xb3, 0x9f, 0xd2, 0x5b, 0x6c, 0x43, 0x1c, 0x07,
    	0x8a, 0x17, 0xf3, 0x64, 0xd6, 0x95, 0x6c, 0x53, 0xd4, 0xd2, 0x4c, 0x77,
    	0x2d, 0x01, 0x3f, 0x87, 0x4d, 0x4c, 0xd0, 0xa2, 0x81, 0x0a, 0xde, 0x59,
    	0x49, 0x44, 0x38, 0xd4, 0xf0, 0x76, 0x7f, 0x6d, 0xcd, 0x90, 0xd6, 0xd0,
    	0xab, 0xac, 0xe3, 0xde, 0x11, 0x38, 0x3e, 0x6f, 0xb7, 0xd2, 0x40, 0x89,
    	0x4d, 0x80, 0x4c, 0x63, 0x2f, 0x3f, 0xc9, 0x9a, 0x26, 0xe0, 0x56, 0x5b,
    	0xf0, 0xf6, 0x59, 0xa1, 0xda, 0xc4, 0xd3, 0x38, 0xd3, 0x3a, 0x30, 0x6f,
    	0x0f, 0xda, 0xe2, 0x27, 0x36, 0xe4, 0xae, 0x50, 0x7f, 0x28, 0xed, 0xc5,
    	0x9c, 0x96, 0x88, 0x90, 0x9b, 0x97, 0xf0, 0xe5, 0x61, 0x0f, 0x6a, 0xa6,
    	0x62, 0x87, 0x3d, 0x9c, 0x6b, 0xe3, 0x21, 0x22, 0xaa, 0xaa
};

    const alt_u8 td_expected_hash[SHA384_LENGTH] = {
        0xe2, 0x4e, 0x75, 0x11, 0xe1, 0x26, 0x99, 0x72, 0x1d, 0x58, 0xea, 0x6b,
        0x5e, 0x05, 0x33, 0x7c, 0xe8, 0xaa, 0xe6, 0x87, 0x21, 0xf5, 0x7c, 0x74,
        0xb8, 0x8b, 0xba, 0xfa, 0xe3, 0xe0, 0x1a, 0x49, 0xfe, 0xc7, 0xae, 0x92,
        0x00, 0x81, 0x56, 0xc6, 0x42, 0xef, 0xf2, 0x98, 0x71, 0xfe, 0xee, 0x2c};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_384_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_48_bytes_data_sha_only)
{
    const alt_u32 td_sha_data_len = 48;

    const alt_u8 td_crypto_data[48] = {
        0xf4, 0x19, 0x76, 0xe9, 0xeb, 0xd2, 0xab, 0x72, 0x8a, 0x78, 0xe1, 0x38,
        0x81, 0x17, 0xb7, 0xf6, 0x8d, 0xd8, 0xa3, 0x6c, 0xbf, 0xfa, 0xd0, 0x7d,
        0xde, 0x60, 0x74, 0xc1, 0x65, 0xfa, 0x42, 0x65, 0x49, 0x29, 0x95, 0x1b,
        0xef, 0xb9, 0x83, 0xf0, 0xf6, 0xc1, 0x46, 0xd6, 0x15, 0x73, 0xfa, 0x09};

    const alt_u8 td_expected_hash[SHA384_LENGTH] = {
        0x62, 0x8a, 0x24, 0x7a, 0x1b, 0x7a, 0x5c, 0xce, 0x28, 0x29, 0x50, 0x15,
        0x29, 0x83, 0x4e, 0xd1, 0x00, 0x84, 0x60, 0x78, 0x51, 0xad, 0xc0, 0x40,
        0xf2, 0x88, 0x12, 0x5c, 0x99, 0x72, 0x05, 0x80, 0xa1, 0x2a, 0x99, 0x67,
        0x75, 0x07, 0xa3, 0x42, 0xea, 0xd6, 0x24, 0x55, 0xd8, 0x89, 0xde, 0x81};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_384_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_96_bytes_root_key_hash)
{
    /*
    --------------------------------------------------------------------------------
    INFO: Preparing to generate 1 patterns of 1 blocks
    --------------------------------------------------------------------------------
    Generating pattern 0 of 96 bytes (768 bits)
    Test Data block 0: 768'h5505DFF8BDAA2842858297885828589B1CEB0DDAE2F84A3F78CD7A7F729F2564509ADCDDD1B457A1B4A76B8E4F1DE9BF5E4677EE951B61EBC82332BE401BA036E535D5E5A94E06817F9296A603A64036B1E901F551F49018F761BBD22C375DA2
    Digest : 384'h3D6E4CC01C7832773063F0E3D23984260DC6F60B97D95FBD328E57F19C232BD7FD62253152EA3F6DEAD73D279AEA1B20
    */

    const alt_u32 test_data_size = 96;

    const alt_u8 test_data[96] = {
              0x55, 0x05, 0xdf, 0xf8, 0xbd, 0xaa, 0x28, 0x42, 0x85, 0x82, 0x97, 0x88,
              0x58, 0x28, 0x58, 0x9b, 0x1c, 0xeb, 0x0d, 0xda, 0xe2, 0xf8, 0x4a, 0x3f,
              0x78, 0xcd, 0x7a, 0x7f, 0x72, 0x9f, 0x25, 0x64, 0x50, 0x9a, 0xdc, 0xdd,
              0xd1, 0xb4, 0x57, 0xa1, 0xb4, 0xa7, 0x6b, 0x8e, 0x4f, 0x1d, 0xe9, 0xbf,
              0x5e, 0x46, 0x77, 0xee, 0x95, 0x1b, 0x61, 0xeb, 0xc8, 0x23, 0x32, 0xbe,
              0x40, 0x1b, 0xa0, 0x36, 0xe5, 0x35, 0xd5, 0xe5, 0xa9, 0x4e, 0x06, 0x81,
              0x7f, 0x92, 0x96, 0xa6, 0x03, 0xa6, 0x40, 0x36, 0xb1, 0xe9, 0x01, 0xf5,
              0x51, 0xf4, 0x90, 0x18, 0xf7, 0x61, 0xbb, 0xd2, 0x2c, 0x37, 0x5d, 0xa2
    };

    const alt_u8 expected_hash[SHA384_LENGTH] = {
              0x3d, 0x6e, 0x4c, 0xc0, 0x1c, 0x78, 0x32, 0x77, 0x30, 0x63, 0xf0, 0xe3,
              0xd2, 0x39, 0x84, 0x26, 0x0d, 0xc6, 0xf6, 0x0b, 0x97, 0xd9, 0x5f, 0xbd,
              0x32, 0x8e, 0x57, 0xf1, 0x9c, 0x23, 0x2b, 0xd7, 0xfd, 0x62, 0x25, 0x31,
              0x52, 0xea, 0x3f, 0x6d, 0xea, 0xd7, 0x3d, 0x27, 0x9a, 0xea, 0x1b, 0x20
    };

    alt_u32* td_crypto_data_ptr = (alt_u32*) test_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));

}

TEST_F(PFRCryptoTest, test_single_block_pattern_sha_only)
{
    // ###################################################################################################################################
    // Generating pattern 0 of 128 bytes (1024 bits)
    // Test Data block 0:
    // 1024'h139189CAE6000DA3CE0600B52E0A3631B39FD25B6C431C078A17F364D6956C53D4D24C772D013F874D4CD0A2810ADE59494438D4F0767F6DCD90D6D0ABACE3DE11383E6FB7D240894D804C632F3FC99A26E0565BF0F659A1DAC4D338D33A306F0FDAE22736E4AE507F28EDC59C9688909B97F0E5610F6AA662873D9C6BE32122
    // Digest : 384'hA518A78E9F6A73DD6113730E04CA9CBA166C8F48A4F24572E1C1F95BBDA20906E5637524CF6778386492D73E6AA06B2E

    const alt_u32 td_sha_data_len = 128;

    const alt_u8 td_crypto_data[128] = {
    		0x13, 0x91, 0x89, 0xca, 0xe6, 0x00, 0x0d, 0xa3, 0xce, 0x06, 0x00, 0xb5,
    		0x2e, 0x0a, 0x36, 0x31, 0xb3, 0x9f, 0xd2, 0x5b, 0x6c, 0x43, 0x1c, 0x07,
    		0x8a, 0x17, 0xf3, 0x64, 0xd6, 0x95, 0x6c, 0x53, 0xd4, 0xd2, 0x4c, 0x77,
    		0x2d, 0x01, 0x3f, 0x87, 0x4d, 0x4c, 0xd0, 0xa2, 0x81, 0x0a, 0xde, 0x59,
    		0x49, 0x44, 0x38, 0xd4, 0xf0, 0x76, 0x7f, 0x6d, 0xcd, 0x90, 0xd6, 0xd0,
			0xab, 0xac, 0xe3, 0xde, 0x11, 0x38, 0x3e, 0x6f, 0xb7, 0xd2, 0x40, 0x89,
    		0x4d, 0x80, 0x4c, 0x63, 0x2f, 0x3f, 0xc9, 0x9a, 0x26, 0xe0, 0x56, 0x5b,
    		0xf0, 0xf6, 0x59, 0xa1, 0xda, 0xc4, 0xd3, 0x38, 0xd3, 0x3a, 0x30, 0x6f,
    		0x0f, 0xda, 0xe2, 0x27, 0x36, 0xe4, 0xae, 0x50, 0x7f, 0x28, 0xed, 0xc5,
    		0x9c, 0x96, 0x88, 0x90, 0x9b, 0x97, 0xf0, 0xe5, 0x61, 0x0f, 0x6a, 0xa6,
    		0x62, 0x87, 0x3d, 0x9c, 0x6b, 0xe3, 0x21, 0x22};

    const alt_u8 td_expected_hash[SHA384_LENGTH] = {
    		0xa5, 0x18, 0xa7, 0x8e, 0x9f, 0x6a, 0x73, 0xdd, 0x61, 0x13, 0x73, 0x0e,
    		0x04, 0xca, 0x9c, 0xba, 0x16, 0x6c, 0x8f, 0x48, 0xa4, 0xf2, 0x45, 0x72,
    		0xe1, 0xc1, 0xf9, 0x5b, 0xbd, 0xa2, 0x09, 0x06, 0xe5, 0x63, 0x75, 0x24,
    		0xcf, 0x67, 0x78, 0x38, 0x64, 0x92, 0xd7, 0x3e, 0x6a, 0xa0, 0x6b, 0x2e};

    alt_u32* td_crypto_data_ptr = (alt_u32*) td_crypto_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) td_expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, td_sha_data_len, CRYPTO_384_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_single_block_pattern_sha_and_ec)
{
    /*
        --------------------------------------------------------------------------------
    INFO: Preparing to generate 1 patterns of 1 blocks
    --------------------------------------------------------------------------------
    Generating pattern 0 of 128 bytes (1024 bits)
    Test Data block 0: 1024'hC99A06DA8BAD33D6EE2D62367B9C5A4EF70DC86F54D88227A51D5A71E3959ADFC3D152714395E363C7E0C0D54914F7BCA22A80B6693861AD4BF8426DC83E2A7DB121000B0956019FD1D283925A0BD997BA20473EA1ECFDE6E83B819E319E055789A2A2E920D4CEC11F3EB7D4E297C4C6566AD366E02F3FD595D2F33C8BB760D7
    Digest : 384'h8D72B620E159B852A389310E037C7E15936987C4AB8243FBB3BB4BFD8B5AA78D4BA2CA363CE7299C610EB02A754E5A65
    Generating curve
    Using curve secp384r1
    Generating private key
    Private Key:
                    384'hB0217E55185B0EA554F7446289B240B11D56E661F1164F496FD9428D90EB4BF39D0A7C40D2DF391289C911B5A9D2EF2B
    Pubkey:
            CX : 384'hD3C40A17E4000515C07E68C9C2F9ED1251BB5E6EA0645CBB10593C71DFDB0358102C82A59F218BFB32F10BB63AF6C16D
            CY : 384'hF5E5BEEEF118DFC840B25B15F8EE105CB544AA4516398BE606BACAEBCC3BB3D32E4DA15F18E5A2EE16C33F38A4F7D987
    Hash:
            E :  384'h8D72B620E159B852A389310E037C7E15936987C4AB8243FBB3BB4BFD8B5AA78D4BA2CA363CE7299C610EB02A754E5A65
    Signature:
            R :  384'hC17CE9E4BB9D02AA5A1DAE369AE8ED1AA48CE90A08635C8081BC11E0FF2608ECB484DD91DCFE63A5CC4967778BFDB75E
            S :  384'h8D5FAD16331E8E030BB892B0CEB35D0715F9C6B9391120B6C52707AE3FB5F2ED97407A0E18FA7628254426816F1F8ADE

    */
    const alt_u32 test_data_size = 128;

    const alt_u8 test_data[128] = {
    		  0xc9, 0x9a, 0x06, 0xda, 0x8b, 0xad, 0x33, 0xd6, 0xee, 0x2d, 0x62, 0x36,
    		  0x7b, 0x9c, 0x5a, 0x4e, 0xf7, 0x0d, 0xc8, 0x6f, 0x54, 0xd8, 0x82, 0x27,
    		  0xa5, 0x1d, 0x5a, 0x71, 0xe3, 0x95, 0x9a, 0xdf, 0xc3, 0xd1, 0x52, 0x71,
    		  0x43, 0x95, 0xe3, 0x63, 0xc7, 0xe0, 0xc0, 0xd5, 0x49, 0x14, 0xf7, 0xbc,
    		  0xa2, 0x2a, 0x80, 0xb6, 0x69, 0x38, 0x61, 0xad, 0x4b, 0xf8, 0x42, 0x6d,
    		  0xc8, 0x3e, 0x2a, 0x7d, 0xb1, 0x21, 0x00, 0x0b, 0x09, 0x56, 0x01, 0x9f,
    		  0xd1, 0xd2, 0x83, 0x92, 0x5a, 0x0b, 0xd9, 0x97, 0xba, 0x20, 0x47, 0x3e,
    		  0xa1, 0xec, 0xfd, 0xe6, 0xe8, 0x3b, 0x81, 0x9e, 0x31, 0x9e, 0x05, 0x57,
    		  0x89, 0xa2, 0xa2, 0xe9, 0x20, 0xd4, 0xce, 0xc1, 0x1f, 0x3e, 0xb7, 0xd4,
    		  0xe2, 0x97, 0xc4, 0xc6, 0x56, 0x6a, 0xd3, 0x66, 0xe0, 0x2f, 0x3f, 0xd5,
    		  0x95, 0xd2, 0xf3, 0x3c, 0x8b, 0xb7, 0x60, 0xd7
    };

    const alt_u8 test_pubkey_cx[SHA384_LENGTH] = {
    		  0xd3, 0xc4, 0x0a, 0x17, 0xe4, 0x00, 0x05, 0x15, 0xc0, 0x7e, 0x68, 0xc9,
    		  0xc2, 0xf9, 0xed, 0x12, 0x51, 0xbb, 0x5e, 0x6e, 0xa0, 0x64, 0x5c, 0xbb,
    		  0x10, 0x59, 0x3c, 0x71, 0xdf, 0xdb, 0x03, 0x58, 0x10, 0x2c, 0x82, 0xa5,
    		  0x9f, 0x21, 0x8b, 0xfb, 0x32, 0xf1, 0x0b, 0xb6, 0x3a, 0xf6, 0xc1, 0x6d
    };

    const alt_u8 test_pubkey_cy[SHA384_LENGTH] = {
    		  0xf5, 0xe5, 0xbe, 0xee, 0xf1, 0x18, 0xdf, 0xc8, 0x40, 0xb2, 0x5b, 0x15,
    		  0xf8, 0xee, 0x10, 0x5c, 0xb5, 0x44, 0xaa, 0x45, 0x16, 0x39, 0x8b, 0xe6,
    		  0x06, 0xba, 0xca, 0xeb, 0xcc, 0x3b, 0xb3, 0xd3, 0x2e, 0x4d, 0xa1, 0x5f,
    		  0x18, 0xe5, 0xa2, 0xee, 0x16, 0xc3, 0x3f, 0x38, 0xa4, 0xf7, 0xd9, 0x87
};

    const alt_u8 test_sig_r[SHA384_LENGTH] = {0xc1, 0x7c, 0xe9, 0xe4, 0xbb, 0x9d, 0x02, 0xaa, 0x5a, 0x1d, 0xae, 0x36,
    		  0x9a, 0xe8, 0xed, 0x1a, 0xa4, 0x8c, 0xe9, 0x0a, 0x08, 0x63, 0x5c, 0x80,
    		  0x81, 0xbc, 0x11, 0xe0, 0xff, 0x26, 0x08, 0xec, 0xb4, 0x84, 0xdd, 0x91,
    		  0xdc, 0xfe, 0x63, 0xa5, 0xcc, 0x49, 0x67, 0x77, 0x8b, 0xfd, 0xb7, 0x5e
};

    const alt_u8 test_sig_s[SHA384_LENGTH] = {0x8d, 0x5f, 0xad, 0x16, 0x33, 0x1e, 0x8e, 0x03, 0x0b, 0xb8, 0x92, 0xb0,
    		  0xce, 0xb3, 0x5d, 0x07, 0x15, 0xf9, 0xc6, 0xb9, 0x39, 0x11, 0x20, 0xb6,
    		  0xc5, 0x27, 0x07, 0xae, 0x3f, 0xb5, 0xf2, 0xed, 0x97, 0x40, 0x7a, 0x0e,
    		  0x18, 0xfa, 0x76, 0x28, 0x25, 0x44, 0x26, 0x81, 0x6f, 0x1f, 0x8a, 0xde
};

    EXPECT_EQ(alt_u32(1),
              verify_ecdsa_and_sha((alt_u32*) test_pubkey_cx,
                                   (alt_u32*) test_pubkey_cy,
                                   (alt_u32*) test_sig_r,
                                   (alt_u32*) test_sig_s,
								   0,
                                   (alt_u32*) test_data,
                                   test_data_size,
                                   CRYPTO_384_MODE,
								   DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_multiple_block_pattern_sha_and_ec)
{
/*
	--------------------------------------------------------------------------------
	INFO: Preparing to generate 1 patterns of 6 blocks
	--------------------------------------------------------------------------------
	Generating pattern 0 of 768 bytes (6144 bits)
	Test Data block 0: 1024'h091C8191C41D8B0F946551A95FCF95A5777F9BA573DEF4F7FDF20DE549E16841EB0A10196786ED4D3DEB64DA00316876F12D8E41AF76EE69BB978CC8F0747E8A117A961C49893D6DB15CAF2C18E6C6BD473E16CB71B25697BEA7E95B1851AA14AABCD04C4DA00941E085891F21F86300AA4D4CED064D67F92D51A5ACF57B3277
	Test Data block 1: 1024'hC771E9B96B604141DEBE6DB8BFB372EAF26178E103817E416FC1DD27E8645FFD37B58593C9138E475395DBEEC429879ACACF678D65D0E6E9F7098AC90490ECD11879C3389FEE8C5B1B9A0DB9F9FFE5188D760A10191F4A9ADD1E56DDCA13A7E331DD1AE6947793086A5F45820663682588869F7B04E3A3D53B5F1D9A39C8F5A2
	Test Data block 2: 1024'h49FD1487BF2786890E4A8A6A48B808D51BB53A26BD5EDC8B2AEB71DC5C9E695CDD5A8C1A3F62B16CF4367445A0C8E88611A25E302200F2C71748C8DD0966A0646905251C7A20688586FDFEFE11B02C119E45E047F1C12FE2D3A2A662F34094DDAC5B095394DBA9E6C436B30B3F77FDA99899539B82659CBEAC607B3E3BEC9E79
	Test Data block 3: 1024'hA49C05204006A85781BEE6348DD363667E825F21571674D4553DA238C73BBA187789D4BBBB2880E28ABD423E113859425A7006A11C320095FB73470EA07B1B470683EC093AA5E36727FAD9761861C033839B0487F3B9C888F8C23420FA91AE403E7B4C1BF7F938B24AC90AC6ED615E862D5D1B3E8AD96B532DBF952843D466E9
	Test Data block 4: 1024'h7B80E081452094114ACF8036B08EBCE9E04DB1F50E78F75773CE877CC94D2BD98148CD2033B1EEA569209C6C0BDCBF5CB2F10F20BA4121FD13FFD65C92318CBC72F4D2CB371C79835B2727C37AE99946084EE670871782661F67F89F882E1F139BB1FED2637BAC42DA454F616DB55F08D4DB543824C20CCA8EFB0C6E218A9ADD
	Test Data block 5: 1024'h23F9E8CBEDB03430ED6A86A5AFD9F2349981626307F52B191FD108E6986F3FF39DBA962E7265D36B7185407C546477E445A78799BF8722AA07A78652D63EF7564C8414E55A2FB8692CD83434A978B7B44B6ABC8AA81394DA3F65F0C1845965716B8ED9FC403618F7FB3EC42CC8D8AA50BA9D3C38B4BDF17A5D06E984940157F1
	Digest : 384'hD161BECEF2914CB9D73231AC4FE044C1FCA6EEE2588B418C89B7FA564F62144BCAA82ADB3DA164C1C2BEFF0866EA8928
	Generating curve
	Using curve secp384r1
	Generating private key
	Private Key:
	                384'h51A9C52846A238FBDCA422B6EACA1CE225DB2A6403D7C1A197DBC34AE78BE78D05BC5747217073C4C064192192B22D49
	Pubkey:
	        CX : 384'h480C2599CDEB52A31A7A343144D68B763FB64D625797CC59904C684F0F8D942F43EAB1C5341DCBB70198468B92CAECD3
	        CY : 384'hFEEE25654AFCDEEDDD442805392E68C03ECEDD98228354328702F310197FF09CEECFE43970DA66AC3F91D8D930B8CEAE
	Hash:
	        E :  384'hD161BECEF2914CB9D73231AC4FE044C1FCA6EEE2588B418C89B7FA564F62144BCAA82ADB3DA164C1C2BEFF0866EA8928
	Signature:
	        R :  384'h5916E5DE66B69EF73877CF96F661AC3E31CD1EB4FFA53DE2D0F7383DD0FB05889F65969A962C9761A6A884C94A85040B
	        S :  384'h2AAB65056090545180F0E54A239F00791CFE494EFD150AD30626255EDF3D7FB23B578F6983EC0A0371E78EC5E606DD53
*/

    const alt_u32 test_data_size = 768;

	const alt_u8 test_data[768] = {
			  0x09, 0x1c, 0x81, 0x91, 0xc4, 0x1d, 0x8b, 0x0f, 0x94, 0x65, 0x51, 0xa9,
			  0x5f, 0xcf, 0x95, 0xa5, 0x77, 0x7f, 0x9b, 0xa5, 0x73, 0xde, 0xf4, 0xf7,
			  0xfd, 0xf2, 0x0d, 0xe5, 0x49, 0xe1, 0x68, 0x41, 0xeb, 0x0a, 0x10, 0x19,
			  0x67, 0x86, 0xed, 0x4d, 0x3d, 0xeb, 0x64, 0xda, 0x00, 0x31, 0x68, 0x76,
			  0xf1, 0x2d, 0x8e, 0x41, 0xaf, 0x76, 0xee, 0x69, 0xbb, 0x97, 0x8c, 0xc8,
			  0xf0, 0x74, 0x7e, 0x8a, 0x11, 0x7a, 0x96, 0x1c, 0x49, 0x89, 0x3d, 0x6d,
			  0xb1, 0x5c, 0xaf, 0x2c, 0x18, 0xe6, 0xc6, 0xbd, 0x47, 0x3e, 0x16, 0xcb,
			  0x71, 0xb2, 0x56, 0x97, 0xbe, 0xa7, 0xe9, 0x5b, 0x18, 0x51, 0xaa, 0x14,
			  0xaa, 0xbc, 0xd0, 0x4c, 0x4d, 0xa0, 0x09, 0x41, 0xe0, 0x85, 0x89, 0x1f,
			  0x21, 0xf8, 0x63, 0x00, 0xaa, 0x4d, 0x4c, 0xed, 0x06, 0x4d, 0x67, 0xf9,
			  0x2d, 0x51, 0xa5, 0xac, 0xf5, 0x7b, 0x32, 0x77,
			  0xc7, 0x71, 0xe9, 0xb9, 0x6b, 0x60, 0x41, 0x41, 0xde, 0xbe, 0x6d, 0xb8,
			  0xbf, 0xb3, 0x72, 0xea, 0xf2, 0x61, 0x78, 0xe1, 0x03, 0x81, 0x7e, 0x41,
			  0x6f, 0xc1, 0xdd, 0x27, 0xe8, 0x64, 0x5f, 0xfd, 0x37, 0xb5, 0x85, 0x93,
			  0xc9, 0x13, 0x8e, 0x47, 0x53, 0x95, 0xdb, 0xee, 0xc4, 0x29, 0x87, 0x9a,
			  0xca, 0xcf, 0x67, 0x8d, 0x65, 0xd0, 0xe6, 0xe9, 0xf7, 0x09, 0x8a, 0xc9,
			  0x04, 0x90, 0xec, 0xd1, 0x18, 0x79, 0xc3, 0x38, 0x9f, 0xee, 0x8c, 0x5b,
			  0x1b, 0x9a, 0x0d, 0xb9, 0xf9, 0xff, 0xe5, 0x18, 0x8d, 0x76, 0x0a, 0x10,
			  0x19, 0x1f, 0x4a, 0x9a, 0xdd, 0x1e, 0x56, 0xdd, 0xca, 0x13, 0xa7, 0xe3,
			  0x31, 0xdd, 0x1a, 0xe6, 0x94, 0x77, 0x93, 0x08, 0x6a, 0x5f, 0x45, 0x82,
			  0x06, 0x63, 0x68, 0x25, 0x88, 0x86, 0x9f, 0x7b, 0x04, 0xe3, 0xa3, 0xd5,
			  0x3b, 0x5f, 0x1d, 0x9a, 0x39, 0xc8, 0xf5, 0xa2,
			  0x49, 0xfd, 0x14, 0x87, 0xbf, 0x27, 0x86, 0x89, 0x0e, 0x4a, 0x8a, 0x6a,
			  0x48, 0xb8, 0x08, 0xd5, 0x1b, 0xb5, 0x3a, 0x26, 0xbd, 0x5e, 0xdc, 0x8b,
			  0x2a, 0xeb, 0x71, 0xdc, 0x5c, 0x9e, 0x69, 0x5c, 0xdd, 0x5a, 0x8c, 0x1a,
			  0x3f, 0x62, 0xb1, 0x6c, 0xf4, 0x36, 0x74, 0x45, 0xa0, 0xc8, 0xe8, 0x86,
			  0x11, 0xa2, 0x5e, 0x30, 0x22, 0x00, 0xf2, 0xc7, 0x17, 0x48, 0xc8, 0xdd,
			  0x09, 0x66, 0xa0, 0x64, 0x69, 0x05, 0x25, 0x1c, 0x7a, 0x20, 0x68, 0x85,
			  0x86, 0xfd, 0xfe, 0xfe, 0x11, 0xb0, 0x2c, 0x11, 0x9e, 0x45, 0xe0, 0x47,
			  0xf1, 0xc1, 0x2f, 0xe2, 0xd3, 0xa2, 0xa6, 0x62, 0xf3, 0x40, 0x94, 0xdd,
			  0xac, 0x5b, 0x09, 0x53, 0x94, 0xdb, 0xa9, 0xe6, 0xc4, 0x36, 0xb3, 0x0b,
			  0x3f, 0x77, 0xfd, 0xa9, 0x98, 0x99, 0x53, 0x9b, 0x82, 0x65, 0x9c, 0xbe,
			  0xac, 0x60, 0x7b, 0x3e, 0x3b, 0xec, 0x9e, 0x79,
			  0xa4, 0x9c, 0x05, 0x20, 0x40, 0x06, 0xa8, 0x57, 0x81, 0xbe, 0xe6, 0x34,
			  0x8d, 0xd3, 0x63, 0x66, 0x7e, 0x82, 0x5f, 0x21, 0x57, 0x16, 0x74, 0xd4,
			  0x55, 0x3d, 0xa2, 0x38, 0xc7, 0x3b, 0xba, 0x18, 0x77, 0x89, 0xd4, 0xbb,
			  0xbb, 0x28, 0x80, 0xe2, 0x8a, 0xbd, 0x42, 0x3e, 0x11, 0x38, 0x59, 0x42,
			  0x5a, 0x70, 0x06, 0xa1, 0x1c, 0x32, 0x00, 0x95, 0xfb, 0x73, 0x47, 0x0e,
			  0xa0, 0x7b, 0x1b, 0x47, 0x06, 0x83, 0xec, 0x09, 0x3a, 0xa5, 0xe3, 0x67,
			  0x27, 0xfa, 0xd9, 0x76, 0x18, 0x61, 0xc0, 0x33, 0x83, 0x9b, 0x04, 0x87,
			  0xf3, 0xb9, 0xc8, 0x88, 0xf8, 0xc2, 0x34, 0x20, 0xfa, 0x91, 0xae, 0x40,
			  0x3e, 0x7b, 0x4c, 0x1b, 0xf7, 0xf9, 0x38, 0xb2, 0x4a, 0xc9, 0x0a, 0xc6,
			  0xed, 0x61, 0x5e, 0x86, 0x2d, 0x5d, 0x1b, 0x3e, 0x8a, 0xd9, 0x6b, 0x53,
			  0x2d, 0xbf, 0x95, 0x28, 0x43, 0xd4, 0x66, 0xe9,
			  0x7b, 0x80, 0xe0, 0x81, 0x45, 0x20, 0x94, 0x11, 0x4a, 0xcf, 0x80, 0x36,
			  0xb0, 0x8e, 0xbc, 0xe9, 0xe0, 0x4d, 0xb1, 0xf5, 0x0e, 0x78, 0xf7, 0x57,
			  0x73, 0xce, 0x87, 0x7c, 0xc9, 0x4d, 0x2b, 0xd9, 0x81, 0x48, 0xcd, 0x20,
			  0x33, 0xb1, 0xee, 0xa5, 0x69, 0x20, 0x9c, 0x6c, 0x0b, 0xdc, 0xbf, 0x5c,
			  0xb2, 0xf1, 0x0f, 0x20, 0xba, 0x41, 0x21, 0xfd, 0x13, 0xff, 0xd6, 0x5c,
			  0x92, 0x31, 0x8c, 0xbc, 0x72, 0xf4, 0xd2, 0xcb, 0x37, 0x1c, 0x79, 0x83,
			  0x5b, 0x27, 0x27, 0xc3, 0x7a, 0xe9, 0x99, 0x46, 0x08, 0x4e, 0xe6, 0x70,
			  0x87, 0x17, 0x82, 0x66, 0x1f, 0x67, 0xf8, 0x9f, 0x88, 0x2e, 0x1f, 0x13,
			  0x9b, 0xb1, 0xfe, 0xd2, 0x63, 0x7b, 0xac, 0x42, 0xda, 0x45, 0x4f, 0x61,
			  0x6d, 0xb5, 0x5f, 0x08, 0xd4, 0xdb, 0x54, 0x38, 0x24, 0xc2, 0x0c, 0xca,
			  0x8e, 0xfb, 0x0c, 0x6e, 0x21, 0x8a, 0x9a, 0xdd,
			  0x23, 0xf9, 0xe8, 0xcb, 0xed, 0xb0, 0x34, 0x30, 0xed, 0x6a, 0x86, 0xa5,
			  0xaf, 0xd9, 0xf2, 0x34, 0x99, 0x81, 0x62, 0x63, 0x07, 0xf5, 0x2b, 0x19,
			  0x1f, 0xd1, 0x08, 0xe6, 0x98, 0x6f, 0x3f, 0xf3, 0x9d, 0xba, 0x96, 0x2e,
			  0x72, 0x65, 0xd3, 0x6b, 0x71, 0x85, 0x40, 0x7c, 0x54, 0x64, 0x77, 0xe4,
			  0x45, 0xa7, 0x87, 0x99, 0xbf, 0x87, 0x22, 0xaa, 0x07, 0xa7, 0x86, 0x52,
			  0xd6, 0x3e, 0xf7, 0x56, 0x4c, 0x84, 0x14, 0xe5, 0x5a, 0x2f, 0xb8, 0x69,
			  0x2c, 0xd8, 0x34, 0x34, 0xa9, 0x78, 0xb7, 0xb4, 0x4b, 0x6a, 0xbc, 0x8a,
			  0xa8, 0x13, 0x94, 0xda, 0x3f, 0x65, 0xf0, 0xc1, 0x84, 0x59, 0x65, 0x71,
			  0x6b, 0x8e, 0xd9, 0xfc, 0x40, 0x36, 0x18, 0xf7, 0xfb, 0x3e, 0xc4, 0x2c,
			  0xc8, 0xd8, 0xaa, 0x50, 0xba, 0x9d, 0x3c, 0x38, 0xb4, 0xbd, 0xf1, 0x7a,
			  0x5d, 0x06, 0xe9, 0x84, 0x94, 0x01, 0x57, 0xf1
	};

	const alt_u8 expected_hash[SHA384_LENGTH] = {
			  0xd1, 0x61, 0xbe, 0xce, 0xf2, 0x91, 0x4c, 0xb9, 0xd7, 0x32, 0x31, 0xac,
			  0x4f, 0xe0, 0x44, 0xc1, 0xfc, 0xa6, 0xee, 0xe2, 0x58, 0x8b, 0x41, 0x8c,
			  0x89, 0xb7, 0xfa, 0x56, 0x4f, 0x62, 0x14, 0x4b, 0xca, 0xa8, 0x2a, 0xdb,
			  0x3d, 0xa1, 0x64, 0xc1, 0xc2, 0xbe, 0xff, 0x08, 0x66, 0xea, 0x89, 0x28
	};

	const alt_u8 test_pubkey_cx[SHA384_LENGTH] = {
			  0x48, 0x0c, 0x25, 0x99, 0xcd, 0xeb, 0x52, 0xa3, 0x1a, 0x7a, 0x34, 0x31,
			  0x44, 0xd6, 0x8b, 0x76, 0x3f, 0xb6, 0x4d, 0x62, 0x57, 0x97, 0xcc, 0x59,
			  0x90, 0x4c, 0x68, 0x4f, 0x0f, 0x8d, 0x94, 0x2f, 0x43, 0xea, 0xb1, 0xc5,
			  0x34, 0x1d, 0xcb, 0xb7, 0x01, 0x98, 0x46, 0x8b, 0x92, 0xca, 0xec, 0xd3
	};

	const alt_u8 test_pubkey_cy[SHA384_LENGTH] = {
			  0xfe, 0xee, 0x25, 0x65, 0x4a, 0xfc, 0xde, 0xed, 0xdd, 0x44, 0x28, 0x05,
			  0x39, 0x2e, 0x68, 0xc0, 0x3e, 0xce, 0xdd, 0x98, 0x22, 0x83, 0x54, 0x32,
			  0x87, 0x02, 0xf3, 0x10, 0x19, 0x7f, 0xf0, 0x9c, 0xee, 0xcf, 0xe4, 0x39,
			  0x70, 0xda, 0x66, 0xac, 0x3f, 0x91, 0xd8, 0xd9, 0x30, 0xb8, 0xce, 0xae
	};

	const alt_u8 test_sig_r[SHA384_LENGTH] = {
			  0x59, 0x16, 0xe5, 0xde, 0x66, 0xb6, 0x9e, 0xf7, 0x38, 0x77, 0xcf, 0x96,
			  0xf6, 0x61, 0xac, 0x3e, 0x31, 0xcd, 0x1e, 0xb4, 0xff, 0xa5, 0x3d, 0xe2,
			  0xd0, 0xf7, 0x38, 0x3d, 0xd0, 0xfb, 0x05, 0x88, 0x9f, 0x65, 0x96, 0x9a,
			  0x96, 0x2c, 0x97, 0x61, 0xa6, 0xa8, 0x84, 0xc9, 0x4a, 0x85, 0x04, 0x0b
	};

	const alt_u8 test_sig_s[SHA384_LENGTH] = {
			  0x2a, 0xab, 0x65, 0x05, 0x60, 0x90, 0x54, 0x51, 0x80, 0xf0, 0xe5, 0x4a,
			  0x23, 0x9f, 0x00, 0x79, 0x1c, 0xfe, 0x49, 0x4e, 0xfd, 0x15, 0x0a, 0xd3,
			  0x06, 0x26, 0x25, 0x5e, 0xdf, 0x3d, 0x7f, 0xb2, 0x3b, 0x57, 0x8f, 0x69,
			  0x83, 0xec, 0x0a, 0x03, 0x71, 0xe7, 0x8e, 0xc5, 0xe6, 0x06, 0xdd, 0x53
	};

    alt_u32* td_crypto_data_ptr = (alt_u32*) test_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));

    EXPECT_EQ(alt_u32(1),
              verify_ecdsa_and_sha((alt_u32*) test_pubkey_cx,
                                   (alt_u32*) test_pubkey_cy,
                                   (alt_u32*) test_sig_r,
                                   (alt_u32*) test_sig_s,
								   0,
                                   (alt_u32*) test_data,
                                   test_data_size,
                                   CRYPTO_384_MODE,
								   DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_dma_execution)
{
    // This unit test loads the BMC SPI Flash image into SPI FLash Mock Memory space.
    // The difference on this unit test is that the DMA is doing the padding of the data instead of NIOS
    // Prepare SPI flash
    SYSTEM_MOCK::get()->load_to_flash(SPI_FLASH_BMC, FULL_PFR_IMAGE_BMC_FILE, FULL_PFR_IMAGE_BMC_FILE_SIZE);
    // Perform provisioning
    SYSTEM_MOCK::get()->provision_ufm_data(UFM_PFR_DATA_EXAMPLE_KEY_FILE);

    switch_spi_flash(SPI_FLASH_BMC);
    alt_u32* bmc_spi_flash_ptr = get_spi_flash_ptr();

    const alt_u8 bmc_expected_hash[SHA384_LENGTH] = {
    	  0x39, 0x32, 0xbf, 0x9a, 0xc8, 0x83, 0x82, 0x53, 0x6b, 0x57, 0xa9, 0xfb,
   		  0x55, 0x23, 0x95, 0x8e, 0xee, 0x93, 0xe6, 0xbd, 0x9c, 0xea, 0x7a, 0x7a,
   		  0x26, 0x20, 0x4f, 0xad, 0x70, 0xb8, 0x25, 0x39, 0xa8, 0x0f, 0xa9, 0x60,
   		  0x9c, 0x1c, 0x45, 0x5c, 0x22, 0x03, 0xcd, 0x0c, 0xc2, 0x9b, 0x1f, 0x10
    };

    alt_u32* bmc_expected_hash_ptr = (alt_u32*) bmc_expected_hash;

    // Start the DMA execution by using this function.
    EXPECT_TRUE(verify_sha(bmc_expected_hash_ptr, 0, bmc_spi_flash_ptr, FULL_PFR_IMAGE_BMC_FILE_SIZE, CRYPTO_384_MODE, ENGAGE_DMA_SPI));
}

TEST_F(PFRCryptoTest, test_dma_execution_ufm)
{
    // This unit test loads the cpld image into UFM FLash Mock Memory space.
    // The difference on this unit test is that the DMA is doing the padding of the data instead of NIOS
    // Load active CPLD image to UFM
    SYSTEM_MOCK::get()->init_x86_mem_from_file(CFM1_ACTIVE_IMAGE_FILE, UFM_MOCK::get()->get_flash_ptr());

    alt_u32* ufm_flash_ptr = UFM_MOCK::get()->get_flash_ptr();

    // Start the DMA execution by using this function.
    alt_u8 cfm1_hash[CFM1_ACTIVE_IMAGE_FILE_HASH_SIZE] = CFM1_ACTIVE_IMAGE_FILE_HASH;
    EXPECT_TRUE(verify_sha((alt_u32*) cfm1_hash, 0, ufm_flash_ptr, CFM1_ACTIVE_IMAGE_FILE_SIZE, CRYPTO_384_MODE, ENGAGE_DMA_UFM));
}

TEST_F(PFRCryptoTest, test_generate_pubkey)
{
    const alt_u32 test_data_size = 768;

	const alt_u8 test_data[768] = {
			  0x09, 0x1c, 0x81, 0x91, 0xc4, 0x1d, 0x8b, 0x0f, 0x94, 0x65, 0x51, 0xa9,
			  0x5f, 0xcf, 0x95, 0xa5, 0x77, 0x7f, 0x9b, 0xa5, 0x73, 0xde, 0xf4, 0xf7,
			  0xfd, 0xf2, 0x0d, 0xe5, 0x49, 0xe1, 0x68, 0x41, 0xeb, 0x0a, 0x10, 0x19,
			  0x67, 0x86, 0xed, 0x4d, 0x3d, 0xeb, 0x64, 0xda, 0x00, 0x31, 0x68, 0x76,
			  0xf1, 0x2d, 0x8e, 0x41, 0xaf, 0x76, 0xee, 0x69, 0xbb, 0x97, 0x8c, 0xc8,
			  0xf0, 0x74, 0x7e, 0x8a, 0x11, 0x7a, 0x96, 0x1c, 0x49, 0x89, 0x3d, 0x6d,
			  0xb1, 0x5c, 0xaf, 0x2c, 0x18, 0xe6, 0xc6, 0xbd, 0x47, 0x3e, 0x16, 0xcb,
			  0x71, 0xb2, 0x56, 0x97, 0xbe, 0xa7, 0xe9, 0x5b, 0x18, 0x51, 0xaa, 0x14,
			  0xaa, 0xbc, 0xd0, 0x4c, 0x4d, 0xa0, 0x09, 0x41, 0xe0, 0x85, 0x89, 0x1f,
			  0x21, 0xf8, 0x63, 0x00, 0xaa, 0x4d, 0x4c, 0xed, 0x06, 0x4d, 0x67, 0xf9,
			  0x2d, 0x51, 0xa5, 0xac, 0xf5, 0x7b, 0x32, 0x77,
			  0xc7, 0x71, 0xe9, 0xb9, 0x6b, 0x60, 0x41, 0x41, 0xde, 0xbe, 0x6d, 0xb8,
			  0xbf, 0xb3, 0x72, 0xea, 0xf2, 0x61, 0x78, 0xe1, 0x03, 0x81, 0x7e, 0x41,
			  0x6f, 0xc1, 0xdd, 0x27, 0xe8, 0x64, 0x5f, 0xfd, 0x37, 0xb5, 0x85, 0x93,
			  0xc9, 0x13, 0x8e, 0x47, 0x53, 0x95, 0xdb, 0xee, 0xc4, 0x29, 0x87, 0x9a,
			  0xca, 0xcf, 0x67, 0x8d, 0x65, 0xd0, 0xe6, 0xe9, 0xf7, 0x09, 0x8a, 0xc9,
			  0x04, 0x90, 0xec, 0xd1, 0x18, 0x79, 0xc3, 0x38, 0x9f, 0xee, 0x8c, 0x5b,
			  0x1b, 0x9a, 0x0d, 0xb9, 0xf9, 0xff, 0xe5, 0x18, 0x8d, 0x76, 0x0a, 0x10,
			  0x19, 0x1f, 0x4a, 0x9a, 0xdd, 0x1e, 0x56, 0xdd, 0xca, 0x13, 0xa7, 0xe3,
			  0x31, 0xdd, 0x1a, 0xe6, 0x94, 0x77, 0x93, 0x08, 0x6a, 0x5f, 0x45, 0x82,
			  0x06, 0x63, 0x68, 0x25, 0x88, 0x86, 0x9f, 0x7b, 0x04, 0xe3, 0xa3, 0xd5,
			  0x3b, 0x5f, 0x1d, 0x9a, 0x39, 0xc8, 0xf5, 0xa2,
			  0x49, 0xfd, 0x14, 0x87, 0xbf, 0x27, 0x86, 0x89, 0x0e, 0x4a, 0x8a, 0x6a,
			  0x48, 0xb8, 0x08, 0xd5, 0x1b, 0xb5, 0x3a, 0x26, 0xbd, 0x5e, 0xdc, 0x8b,
			  0x2a, 0xeb, 0x71, 0xdc, 0x5c, 0x9e, 0x69, 0x5c, 0xdd, 0x5a, 0x8c, 0x1a,
			  0x3f, 0x62, 0xb1, 0x6c, 0xf4, 0x36, 0x74, 0x45, 0xa0, 0xc8, 0xe8, 0x86,
			  0x11, 0xa2, 0x5e, 0x30, 0x22, 0x00, 0xf2, 0xc7, 0x17, 0x48, 0xc8, 0xdd,
			  0x09, 0x66, 0xa0, 0x64, 0x69, 0x05, 0x25, 0x1c, 0x7a, 0x20, 0x68, 0x85,
			  0x86, 0xfd, 0xfe, 0xfe, 0x11, 0xb0, 0x2c, 0x11, 0x9e, 0x45, 0xe0, 0x47,
			  0xf1, 0xc1, 0x2f, 0xe2, 0xd3, 0xa2, 0xa6, 0x62, 0xf3, 0x40, 0x94, 0xdd,
			  0xac, 0x5b, 0x09, 0x53, 0x94, 0xdb, 0xa9, 0xe6, 0xc4, 0x36, 0xb3, 0x0b,
			  0x3f, 0x77, 0xfd, 0xa9, 0x98, 0x99, 0x53, 0x9b, 0x82, 0x65, 0x9c, 0xbe,
			  0xac, 0x60, 0x7b, 0x3e, 0x3b, 0xec, 0x9e, 0x79,
			  0xa4, 0x9c, 0x05, 0x20, 0x40, 0x06, 0xa8, 0x57, 0x81, 0xbe, 0xe6, 0x34,
			  0x8d, 0xd3, 0x63, 0x66, 0x7e, 0x82, 0x5f, 0x21, 0x57, 0x16, 0x74, 0xd4,
			  0x55, 0x3d, 0xa2, 0x38, 0xc7, 0x3b, 0xba, 0x18, 0x77, 0x89, 0xd4, 0xbb,
			  0xbb, 0x28, 0x80, 0xe2, 0x8a, 0xbd, 0x42, 0x3e, 0x11, 0x38, 0x59, 0x42,
			  0x5a, 0x70, 0x06, 0xa1, 0x1c, 0x32, 0x00, 0x95, 0xfb, 0x73, 0x47, 0x0e,
			  0xa0, 0x7b, 0x1b, 0x47, 0x06, 0x83, 0xec, 0x09, 0x3a, 0xa5, 0xe3, 0x67,
			  0x27, 0xfa, 0xd9, 0x76, 0x18, 0x61, 0xc0, 0x33, 0x83, 0x9b, 0x04, 0x87,
			  0xf3, 0xb9, 0xc8, 0x88, 0xf8, 0xc2, 0x34, 0x20, 0xfa, 0x91, 0xae, 0x40,
			  0x3e, 0x7b, 0x4c, 0x1b, 0xf7, 0xf9, 0x38, 0xb2, 0x4a, 0xc9, 0x0a, 0xc6,
			  0xed, 0x61, 0x5e, 0x86, 0x2d, 0x5d, 0x1b, 0x3e, 0x8a, 0xd9, 0x6b, 0x53,
			  0x2d, 0xbf, 0x95, 0x28, 0x43, 0xd4, 0x66, 0xe9,
			  0x7b, 0x80, 0xe0, 0x81, 0x45, 0x20, 0x94, 0x11, 0x4a, 0xcf, 0x80, 0x36,
			  0xb0, 0x8e, 0xbc, 0xe9, 0xe0, 0x4d, 0xb1, 0xf5, 0x0e, 0x78, 0xf7, 0x57,
			  0x73, 0xce, 0x87, 0x7c, 0xc9, 0x4d, 0x2b, 0xd9, 0x81, 0x48, 0xcd, 0x20,
			  0x33, 0xb1, 0xee, 0xa5, 0x69, 0x20, 0x9c, 0x6c, 0x0b, 0xdc, 0xbf, 0x5c,
			  0xb2, 0xf1, 0x0f, 0x20, 0xba, 0x41, 0x21, 0xfd, 0x13, 0xff, 0xd6, 0x5c,
			  0x92, 0x31, 0x8c, 0xbc, 0x72, 0xf4, 0xd2, 0xcb, 0x37, 0x1c, 0x79, 0x83,
			  0x5b, 0x27, 0x27, 0xc3, 0x7a, 0xe9, 0x99, 0x46, 0x08, 0x4e, 0xe6, 0x70,
			  0x87, 0x17, 0x82, 0x66, 0x1f, 0x67, 0xf8, 0x9f, 0x88, 0x2e, 0x1f, 0x13,
			  0x9b, 0xb1, 0xfe, 0xd2, 0x63, 0x7b, 0xac, 0x42, 0xda, 0x45, 0x4f, 0x61,
			  0x6d, 0xb5, 0x5f, 0x08, 0xd4, 0xdb, 0x54, 0x38, 0x24, 0xc2, 0x0c, 0xca,
			  0x8e, 0xfb, 0x0c, 0x6e, 0x21, 0x8a, 0x9a, 0xdd,
			  0x23, 0xf9, 0xe8, 0xcb, 0xed, 0xb0, 0x34, 0x30, 0xed, 0x6a, 0x86, 0xa5,
			  0xaf, 0xd9, 0xf2, 0x34, 0x99, 0x81, 0x62, 0x63, 0x07, 0xf5, 0x2b, 0x19,
			  0x1f, 0xd1, 0x08, 0xe6, 0x98, 0x6f, 0x3f, 0xf3, 0x9d, 0xba, 0x96, 0x2e,
			  0x72, 0x65, 0xd3, 0x6b, 0x71, 0x85, 0x40, 0x7c, 0x54, 0x64, 0x77, 0xe4,
			  0x45, 0xa7, 0x87, 0x99, 0xbf, 0x87, 0x22, 0xaa, 0x07, 0xa7, 0x86, 0x52,
			  0xd6, 0x3e, 0xf7, 0x56, 0x4c, 0x84, 0x14, 0xe5, 0x5a, 0x2f, 0xb8, 0x69,
			  0x2c, 0xd8, 0x34, 0x34, 0xa9, 0x78, 0xb7, 0xb4, 0x4b, 0x6a, 0xbc, 0x8a,
			  0xa8, 0x13, 0x94, 0xda, 0x3f, 0x65, 0xf0, 0xc1, 0x84, 0x59, 0x65, 0x71,
			  0x6b, 0x8e, 0xd9, 0xfc, 0x40, 0x36, 0x18, 0xf7, 0xfb, 0x3e, 0xc4, 0x2c,
			  0xc8, 0xd8, 0xaa, 0x50, 0xba, 0x9d, 0x3c, 0x38, 0xb4, 0xbd, 0xf1, 0x7a,
			  0x5d, 0x06, 0xe9, 0x84, 0x94, 0x01, 0x57, 0xf1
	};

	const alt_u8 expected_hash[SHA384_LENGTH] = {
			  0xd1, 0x61, 0xbe, 0xce, 0xf2, 0x91, 0x4c, 0xb9, 0xd7, 0x32, 0x31, 0xac,
			  0x4f, 0xe0, 0x44, 0xc1, 0xfc, 0xa6, 0xee, 0xe2, 0x58, 0x8b, 0x41, 0x8c,
			  0x89, 0xb7, 0xfa, 0x56, 0x4f, 0x62, 0x14, 0x4b, 0xca, 0xa8, 0x2a, 0xdb,
			  0x3d, 0xa1, 0x64, 0xc1, 0xc2, 0xbe, 0xff, 0x08, 0x66, 0xea, 0x89, 0x28
	};

	const alt_u8 test_pubkey_cx[SHA384_LENGTH] = {
			  0x48, 0x0c, 0x25, 0x99, 0xcd, 0xeb, 0x52, 0xa3, 0x1a, 0x7a, 0x34, 0x31,
			  0x44, 0xd6, 0x8b, 0x76, 0x3f, 0xb6, 0x4d, 0x62, 0x57, 0x97, 0xcc, 0x59,
			  0x90, 0x4c, 0x68, 0x4f, 0x0f, 0x8d, 0x94, 0x2f, 0x43, 0xea, 0xb1, 0xc5,
			  0x34, 0x1d, 0xcb, 0xb7, 0x01, 0x98, 0x46, 0x8b, 0x92, 0xca, 0xec, 0xd3
	};

	const alt_u8 test_pubkey_cy[SHA384_LENGTH] = {
			  0xfe, 0xee, 0x25, 0x65, 0x4a, 0xfc, 0xde, 0xed, 0xdd, 0x44, 0x28, 0x05,
			  0x39, 0x2e, 0x68, 0xc0, 0x3e, 0xce, 0xdd, 0x98, 0x22, 0x83, 0x54, 0x32,
			  0x87, 0x02, 0xf3, 0x10, 0x19, 0x7f, 0xf0, 0x9c, 0xee, 0xcf, 0xe4, 0x39,
			  0x70, 0xda, 0x66, 0xac, 0x3f, 0x91, 0xd8, 0xd9, 0x30, 0xb8, 0xce, 0xae
	};

	const alt_u8 test_sig_r[SHA384_LENGTH] = {
			  0x59, 0x16, 0xe5, 0xde, 0x66, 0xb6, 0x9e, 0xf7, 0x38, 0x77, 0xcf, 0x96,
			  0xf6, 0x61, 0xac, 0x3e, 0x31, 0xcd, 0x1e, 0xb4, 0xff, 0xa5, 0x3d, 0xe2,
			  0xd0, 0xf7, 0x38, 0x3d, 0xd0, 0xfb, 0x05, 0x88, 0x9f, 0x65, 0x96, 0x9a,
			  0x96, 0x2c, 0x97, 0x61, 0xa6, 0xa8, 0x84, 0xc9, 0x4a, 0x85, 0x04, 0x0b
	};

	const alt_u8 test_sig_s[SHA384_LENGTH] = {
			  0x2a, 0xab, 0x65, 0x05, 0x60, 0x90, 0x54, 0x51, 0x80, 0xf0, 0xe5, 0x4a,
			  0x23, 0x9f, 0x00, 0x79, 0x1c, 0xfe, 0x49, 0x4e, 0xfd, 0x15, 0x0a, 0xd3,
			  0x06, 0x26, 0x25, 0x5e, 0xdf, 0x3d, 0x7f, 0xb2, 0x3b, 0x57, 0x8f, 0x69,
			  0x83, 0xec, 0x0a, 0x03, 0x71, 0xe7, 0x8e, 0xc5, 0xe6, 0x06, 0xdd, 0x53
	};

    alt_u32* td_crypto_data_ptr = (alt_u32*) test_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));

    EXPECT_EQ(alt_u32(1),
              verify_ecdsa_and_sha((alt_u32*) test_pubkey_cx,
                                   (alt_u32*) test_pubkey_cy,
                                   (alt_u32*) test_sig_r,
                                   (alt_u32*) test_sig_s,
								   0,
                                   (alt_u32*) test_data,
                                   test_data_size,
                                   CRYPTO_384_MODE,
								   DISENGAGE_DMA));

    static const alt_u8 crypto_ec_da_384[SHA384_LENGTH] = {
        0xcd, 0x80, 0x28, 0x3e, 0x15, 0x2c, 0x3f, 0x9f, 0x34, 0x68, 0x92, 0xbc, 0xbf, 0xce, 0x86, 0x1f,
        0x6d, 0x0a, 0x22, 0xae, 0x18, 0xdd, 0x2a, 0xa5, 0x93, 0x82, 0x0f, 0xd2, 0xbe, 0x43, 0x50, 0xa9,
        0x6b, 0xa3, 0x88, 0xa5, 0x1b, 0xfd, 0xb1, 0x4d, 0x42, 0x1e, 0x62, 0xd6, 0x11, 0xbc, 0x50, 0x70};

    alt_u32 pubkey_cx[12] = {0};
    alt_u32 pubkey_cy[12] = {0};

    // generate_pubkey will return 1 if the created public key matches the expected public key.
    // Bound to change when fw changes.
    EXPECT_EQ(alt_u32(1), generate_pubkey((alt_u32*)pubkey_cx, (alt_u32*)pubkey_cy, (alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE));
}

// Test if the the algorithm for checking the validity of hmac works or not.
// Four cases where HMAC can be: 1) bigger than ec_n
//                                2) smaller than ec_n
//                                3) equal to ec_n
//                                4) zero
TEST_F(PFRCryptoTest, test_random_data_bigger_than_ec_n)
{
    static const alt_u8 ec_n_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73};

    static const alt_u8 random_data_all_bytes_big_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff};

    static const alt_u8 random_data_big_bytes_in_middle_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0xef, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x7a, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73};

    static const alt_u8 random_data_big_bytes_in_lsb_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0xee, 0xcc, 0xc5, 0x29, 0x73};

    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)random_data_all_bytes_big_384, (alt_u32*) ec_n_384, CRYPTO_384_MODE));
    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)random_data_big_bytes_in_middle_384, (alt_u32*) ec_n_384, CRYPTO_384_MODE));
    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)random_data_big_bytes_in_lsb_384, (alt_u32*) ec_n_384, CRYPTO_384_MODE));
}

TEST_F(PFRCryptoTest, test_random_data_smaller_than_ec_n)
{
    static const alt_u8 ec_n_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73};

    static const alt_u8 random_data_small_bytes_at_msb_384[SHA384_LENGTH] = {
        0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73};

    static const alt_u8 random_data_small_bytes_in_middle_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73};

    static const alt_u8 random_data_small_bytes_at_lsb_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x00};

    EXPECT_EQ(alt_u32(1), check_hmac_validity((alt_u32*)random_data_small_bytes_at_msb_384, (alt_u32*) ec_n_384, CRYPTO_384_MODE));
    EXPECT_EQ(alt_u32(1), check_hmac_validity((alt_u32*)random_data_small_bytes_in_middle_384, (alt_u32*) ec_n_384, CRYPTO_384_MODE));
    EXPECT_EQ(alt_u32(1), check_hmac_validity((alt_u32*)random_data_small_bytes_at_lsb_384, (alt_u32*) ec_n_384, CRYPTO_384_MODE));
}

TEST_F(PFRCryptoTest, test_random_data_all_zeros)
{
    static const alt_u8 ec_n_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73};

    static const alt_u8 random_data_384[SHA384_LENGTH] = {
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)random_data_384, (alt_u32*) ec_n_384, CRYPTO_384_MODE));
}

TEST_F(PFRCryptoTest, test_equal_value_data)
{
    static const alt_u8 ec_n_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73};

    static const alt_u8 random_data_384[SHA384_LENGTH] = {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc7, 0x63, 0x4d, 0x81, 0xf4, 0x37, 0x2d, 0xdf,
        0x58, 0x1a, 0x0d, 0xb2, 0x48, 0xb0, 0xa7, 0x7a, 0xec, 0xec, 0x19, 0x6a, 0xcc, 0xc5, 0x29, 0x73};

    EXPECT_EQ(alt_u32(0), check_hmac_validity((alt_u32*)random_data_384, (alt_u32*) ec_n_384, CRYPTO_384_MODE));
}

/**
 * @brief Check if the entropy extractor (mock system) is even random in the first place.
 */
TEST_F(PFRCryptoTest, test_randomization_of_entropy_extractor)
{
    alt_u32 entropy_sample_one[64] = {0};
    alt_u32 entropy_sample_two[64] = {0};
    alt_u32 counter = 0;
    alt_u32 is_random = 1;

    extract_entropy_data((alt_u32*)entropy_sample_one, SHA384_HMAC_ENTROPY);

    std::this_thread::sleep_for(std::chrono::milliseconds(1000));

    extract_entropy_data((alt_u32*)entropy_sample_two, SHA384_HMAC_ENTROPY);

    for (alt_u32 i = 0; i < SHA384_HMAC_ENTROPY; i++)
    {
    	if (entropy_sample_one[i] == entropy_sample_two[i])
    	{
    		counter++;
    		if (counter == SHA384_HMAC_ENTROPY)
    		{
    		    is_random = 0;
                counter = 0;
    		}
    	}
    }

    EXPECT_EQ(alt_u32(1), is_random);
}

/**
 * @brief This algorithm is tested by manually computing the HMAC calculation.
 * The HMAC calculation here is done by using openssl function manually.
 * sha256sum and sha384sum is used to compute the hash.
 * These data are manually appended together.
 * The purpose of this test is to make sure firmware is able to reproduce the expected HMAC correctly.
 */
TEST_F(PFRCryptoTest, test_hmac_algorithm_computation_1)
{
    alt_u8 XOR_K0_AND_IPAD_384[CRYPTO_BLOCK_SIZE_FOR_384] = {
              0x38, 0x44, 0x50, 0xc1, 0xb6, 0x10, 0x70, 0xca, 0xc5, 0x84, 0x9f, 0x40,
              0x98, 0xdf, 0xe0, 0x0f, 0xb8, 0xff, 0x6a, 0x2c, 0x63, 0xab, 0x56, 0xbb,
              0x0b, 0x80, 0xc9, 0x6d, 0xe7, 0x0e, 0xad, 0x41, 0xe5, 0x0a, 0x93, 0x89,
              0x08, 0x25, 0xa5, 0x73, 0x5e, 0x8e, 0x79, 0x5d, 0xee, 0xc5, 0x43, 0x64,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36};

    alt_u8 XOR_K0_AND_OPAD_384[CRYPTO_BLOCK_SIZE_FOR_384] = {
              0x52, 0x2e, 0x3a, 0xab, 0xdc, 0x7a, 0x1a, 0xa0, 0xaf, 0xee, 0xf5, 0x2a,
              0xf2, 0xb5, 0x8a, 0x65, 0xd2, 0x95, 0x00, 0x46, 0x09, 0xc1, 0x3c, 0xd1,
              0x61, 0xea, 0xa3, 0x07, 0x8d, 0x64, 0xc7, 0x2b, 0x8f, 0x60, 0xf9, 0xe3,
              0x62, 0x4f, 0xcf, 0x19, 0x34, 0xe4, 0x13, 0x37, 0x84, 0xaf, 0x29, 0x0e,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c};

    alt_u8 entropy_sample_output[256];
    std::fill_n(entropy_sample_output, 256, 0xa3);

	alt_u8 expected_precomputed_hmac_384[SHA384_LENGTH] = {
			0x37, 0xc2, 0x7b, 0x4b, 0xc8, 0xc7, 0x64, 0x9a, 0xfb, 0x21, 0xc1, 0xe8,
			0xa3, 0xac, 0x97, 0xec, 0xbf, 0xed, 0x9b, 0xb5, 0x74, 0x5b, 0xef, 0xc6,
			0x65, 0x3b, 0x54, 0xf5, 0xc0, 0x03, 0xc7, 0x66, 0x37, 0x76, 0x40, 0xb9,
			0x42, 0x20, 0x48, 0xaa, 0x3b, 0xcc, 0x0f, 0x70, 0x93, 0x4e, 0xde, 0x63};

	static alt_u8 hmac_384[SHA384_LENGTH] = {0};

	compute_hmac_algorithm((alt_u32*)hmac_384, (alt_u32*)entropy_sample_output, (alt_u32*)XOR_K0_AND_IPAD_384, (alt_u32*)XOR_K0_AND_OPAD_384, CRYPTO_384_MODE);

	alt_u32 indicator = 1;

	for (alt_u32 i = 0; i < SHA384_LENGTH; i++)
	{
		if (hmac_384[i] != expected_precomputed_hmac_384[i])
		{
			indicator = 0;
		}
	}

	EXPECT_EQ(alt_u32(1), indicator);
}

TEST_F(PFRCryptoTest, test_hmac_algorithm_computation_2)
{
    alt_u8 XOR_K0_AND_IPAD_384[CRYPTO_BLOCK_SIZE_FOR_384] = {
              0xca, 0x08, 0xf5, 0x8e, 0x9d, 0x41, 0x18, 0x71, 0xd4, 0x7a, 0x9f, 0x97,
              0x11, 0x80, 0x2f, 0x94, 0x97, 0x05, 0xdd, 0xca, 0xde, 0xa2, 0x2b, 0x38,
              0x3c, 0xdd, 0x5e, 0x35, 0x31, 0xf9, 0x35, 0x95, 0xdf, 0xae, 0xa2, 0xda,
              0x22, 0xcb, 0x28, 0xae, 0xe6, 0x86, 0xb9, 0x3f, 0xb6, 0x7e, 0x15, 0x86,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36};

    alt_u8 XOR_K0_AND_OPAD_384[CRYPTO_BLOCK_SIZE_FOR_384] = {
              0x4f, 0x62, 0x30, 0x40, 0xe8, 0x3a, 0x03, 0x97, 0xcd, 0x5a, 0x27, 0xaf,
              0x49, 0x19, 0x49, 0x35, 0x7b, 0x2d, 0x31, 0xbb, 0x8e, 0x30, 0x80, 0x14,
              0xe0, 0x11, 0xd5, 0xb3, 0xbe, 0x7c, 0xe1, 0x2f, 0xab, 0x7f, 0xfd, 0x8f,
              0x38, 0x8a, 0x68, 0xf6, 0xc2, 0xb1, 0x0e, 0x4d, 0xe2, 0xcf, 0x7c, 0x2b,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c};

    alt_u8 entropy_sample_output[256];
    std::fill_n(entropy_sample_output, 256, 0xa3);

    alt_u8 expected_precomputed_hmac_384[SHA384_LENGTH] = {
			0x0b, 0x07, 0xe5, 0x83, 0x79, 0x17, 0x43, 0x7d, 0x30, 0x2e, 0x95, 0x28,
			0x4c, 0x52, 0xee, 0x0a, 0x7d, 0xfb, 0xd0, 0x1b, 0xb4, 0x9c, 0x5b, 0x91,
			0x9f, 0xf9, 0xef, 0x96, 0xaa, 0xe7, 0x4b, 0x8f, 0x5f, 0xb6, 0x5f, 0x0c,
			0x27, 0x12, 0x88, 0x0e, 0x1c, 0xf4, 0x71, 0x52, 0x4f, 0x0f, 0x60, 0xe2};

	static alt_u8 hmac_384[SHA384_LENGTH] = {0};

	compute_hmac_algorithm((alt_u32*)hmac_384, (alt_u32*)entropy_sample_output, (alt_u32*)XOR_K0_AND_IPAD_384, (alt_u32*)XOR_K0_AND_OPAD_384, CRYPTO_384_MODE);

	alt_u32 indicator = 1;

	for (alt_u32 i = 0; i < SHA384_LENGTH; i++)
	{
		if (hmac_384[i] != expected_precomputed_hmac_384[i])
		{
			indicator = 0;
		}
	}

	EXPECT_EQ(alt_u32(1), indicator);
}

/**
 * @brief following test uses a different entropy sample output
 */
TEST_F(PFRCryptoTest, test_hmac_algorithm_computation_3)
{
    alt_u8 XOR_K0_AND_IPAD_384[CRYPTO_BLOCK_SIZE_FOR_384] = {
              0xca, 0x08, 0xf5, 0x8e, 0x9d, 0x41, 0x18, 0x71, 0xd4, 0x7a, 0x9f, 0x97,
              0x11, 0x80, 0x2f, 0x94, 0x97, 0x05, 0xdd, 0xca, 0xde, 0xa2, 0x2b, 0x38,
              0x3c, 0xdd, 0x5e, 0x35, 0x31, 0xf9, 0x35, 0x95, 0xdf, 0xae, 0xa2, 0xda,
              0x22, 0xcb, 0x28, 0xae, 0xe6, 0x86, 0xb9, 0x3f, 0xb6, 0x7e, 0x15, 0x86,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
              0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36};

    alt_u8 XOR_K0_AND_OPAD_384[CRYPTO_BLOCK_SIZE_FOR_384] = {
              0x4f, 0x62, 0x30, 0x40, 0xe8, 0x3a, 0x03, 0x97, 0xcd, 0x5a, 0x27, 0xaf,
              0x49, 0x19, 0x49, 0x35, 0x7b, 0x2d, 0x31, 0xbb, 0x8e, 0x30, 0x80, 0x14,
              0xe0, 0x11, 0xd5, 0xb3, 0xbe, 0x7c, 0xe1, 0x2f, 0xab, 0x7f, 0xfd, 0x8f,
              0x38, 0x8a, 0x68, 0xf6, 0xc2, 0xb1, 0x0e, 0x4d, 0xe2, 0xcf, 0x7c, 0x2b,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,
              0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c};

    alt_u8 entropy_sample_output[256];
    std::fill_n(entropy_sample_output, 256, 0x12);

    alt_u8 expected_precomputed_hmac_384[SHA384_LENGTH] = {
    		0x57, 0x98, 0xf6, 0x8d, 0x86, 0xc4, 0xd0, 0xe6, 0x8b, 0xb7, 0x3a, 0xad,
			0x34, 0x23, 0x46, 0xd8, 0xc7, 0x79, 0x1c, 0x4a, 0xf4, 0x94, 0xcc, 0x5e,
			0x2e, 0x7d, 0x74, 0x06, 0xce, 0xfe, 0x5d, 0x56, 0x53, 0xdb, 0x9f, 0x69,
			0xde, 0x68, 0x02, 0x37, 0x49, 0xda, 0xa1, 0x22, 0xc7, 0xd1, 0xbc, 0xe7};

	static alt_u8 hmac_384[SHA384_LENGTH] = {0};

	compute_hmac_algorithm((alt_u32*)hmac_384, (alt_u32*)entropy_sample_output, (alt_u32*)XOR_K0_AND_IPAD_384, (alt_u32*)XOR_K0_AND_OPAD_384, CRYPTO_384_MODE);

	alt_u32 indicator = 1;

	for (alt_u32 i = 0; i < SHA384_LENGTH; i++)
	{
		if (hmac_384[i] != expected_precomputed_hmac_384[i])
		{
			indicator = 0;
		}
	}

	EXPECT_EQ(alt_u32(1), indicator);
}

/**
 * @brief Test the generation of ecdsa-384 signature with 96 bytes data
 * and verify this signature.
 */
TEST_F(PFRCryptoTest, test_generate_384_signature_with_96_bytes_data)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_384[SHA384_LENGTH] = {
        0xcd, 0x80, 0x28, 0x3e, 0x15, 0x2c, 0x3f, 0x9f, 0x34, 0x68, 0x92, 0xbc, 0xbf, 0xce, 0x86, 0x1f,
        0x6d, 0x0a, 0x22, 0xae, 0x18, 0xdd, 0x2a, 0xa5, 0x93, 0x82, 0x0f, 0xd2, 0xbe, 0x43, 0x50, 0xa9,
        0x6b, 0xa3, 0x88, 0xa5, 0x1b, 0xfd, 0xb1, 0x4d, 0x42, 0x1e, 0x62, 0xd6, 0x11, 0xbc, 0x50, 0x70};

    const alt_u8 crypto_pub_cx_384[SHA384_LENGTH] = {
        0xe5, 0x42, 0x3d, 0x97, 0xff, 0xfb, 0x23, 0xa9, 0xa6, 0x2c, 0x98, 0x8a, 0x25, 0x90, 0x2f, 0x72,
        0xca, 0x19, 0xd1, 0x76, 0x60, 0x15, 0x80, 0x42, 0xd0, 0xf9, 0x5c, 0xf7, 0xcb, 0x05, 0x78, 0x86,
        0xf6, 0x70, 0x17, 0xb5, 0xab, 0x09, 0xe8, 0xc0, 0x96, 0xb7, 0xd3, 0x15, 0x2f, 0x52, 0x7e, 0x92};

    const alt_u8 crypto_pub_cy_384[SHA384_LENGTH] = {
        0xfd, 0x87, 0x43, 0x35, 0xd3, 0xfe, 0x31, 0xbb, 0x4e, 0xbe, 0xee, 0x38, 0xe2, 0x03, 0x64, 0x07,
        0x1e, 0xa1, 0x71, 0x65, 0xd9, 0xc1, 0x72, 0x54, 0xa5, 0x77, 0x81, 0x70, 0x4e, 0xbf, 0x03, 0xa4,
        0x3a, 0xdb, 0x7c, 0xdb, 0x18, 0x3f, 0xc3, 0x24, 0x06, 0x28, 0x97, 0x1a, 0x18, 0x78, 0xc3, 0xa2};

    const alt_u32 test_data_size = 96;

    const alt_u8 test_data[96] = {
              0x55, 0x05, 0xdf, 0xf8, 0xbd, 0xaa, 0x28, 0x42, 0x85, 0x82, 0x97, 0x88,
              0x58, 0x28, 0x58, 0x9b, 0x1c, 0xeb, 0x0d, 0xda, 0xe2, 0xf8, 0x4a, 0x3f,
              0x78, 0xcd, 0x7a, 0x7f, 0x72, 0x9f, 0x25, 0x64, 0x50, 0x9a, 0xdc, 0xdd,
              0xd1, 0xb4, 0x57, 0xa1, 0xb4, 0xa7, 0x6b, 0x8e, 0x4f, 0x1d, 0xe9, 0xbf,
              0x5e, 0x46, 0x77, 0xee, 0x95, 0x1b, 0x61, 0xeb, 0xc8, 0x23, 0x32, 0xbe,
              0x40, 0x1b, 0xa0, 0x36, 0xe5, 0x35, 0xd5, 0xe5, 0xa9, 0x4e, 0x06, 0x81,
              0x7f, 0x92, 0x96, 0xa6, 0x03, 0xa6, 0x40, 0x36, 0xb1, 0xe9, 0x01, 0xf5,
              0x51, 0xf4, 0x90, 0x18, 0xf7, 0x61, 0xbb, 0xd2, 0x2c, 0x37, 0x5d, 0xa2
    };

    alt_u32 sig_r[12] = {0};
    alt_u32 sig_s[12] = {0};

    // Generate the signature using the message and keys and store it.
    generate_ecdsa_signature(sig_r, sig_s, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE);

    // Verify the generated signature.
    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_pub_cy_384, (const alt_u32*)sig_r, (const alt_u32*)sig_s, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));
}

/**
 * @brief Test the generation of ecdsa-384 signature with 128 bytes data
 * and verify this signature.
 */
TEST_F(PFRCryptoTest, test_generate_384_signature_with_single_sha_block)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_384[SHA384_LENGTH] = {
        0xcd, 0x80, 0x28, 0x3e, 0x15, 0x2c, 0x3f, 0x9f, 0x34, 0x68, 0x92, 0xbc, 0xbf, 0xce, 0x86, 0x1f,
        0x6d, 0x0a, 0x22, 0xae, 0x18, 0xdd, 0x2a, 0xa5, 0x93, 0x82, 0x0f, 0xd2, 0xbe, 0x43, 0x50, 0xa9,
        0x6b, 0xa3, 0x88, 0xa5, 0x1b, 0xfd, 0xb1, 0x4d, 0x42, 0x1e, 0x62, 0xd6, 0x11, 0xbc, 0x50, 0x70};

    const alt_u8 crypto_pub_cx_384[SHA384_LENGTH] = {
        0xe5, 0x42, 0x3d, 0x97, 0xff, 0xfb, 0x23, 0xa9, 0xa6, 0x2c, 0x98, 0x8a, 0x25, 0x90, 0x2f, 0x72,
        0xca, 0x19, 0xd1, 0x76, 0x60, 0x15, 0x80, 0x42, 0xd0, 0xf9, 0x5c, 0xf7, 0xcb, 0x05, 0x78, 0x86,
        0xf6, 0x70, 0x17, 0xb5, 0xab, 0x09, 0xe8, 0xc0, 0x96, 0xb7, 0xd3, 0x15, 0x2f, 0x52, 0x7e, 0x92};

    const alt_u8 crypto_pub_cy_384[SHA384_LENGTH] = {
        0xfd, 0x87, 0x43, 0x35, 0xd3, 0xfe, 0x31, 0xbb, 0x4e, 0xbe, 0xee, 0x38, 0xe2, 0x03, 0x64, 0x07,
        0x1e, 0xa1, 0x71, 0x65, 0xd9, 0xc1, 0x72, 0x54, 0xa5, 0x77, 0x81, 0x70, 0x4e, 0xbf, 0x03, 0xa4,
        0x3a, 0xdb, 0x7c, 0xdb, 0x18, 0x3f, 0xc3, 0x24, 0x06, 0x28, 0x97, 0x1a, 0x18, 0x78, 0xc3, 0xa2};

    const alt_u32 test_data_size = 128;

    const alt_u8 test_data[128] = {
        0x86, 0x3a, 0x60, 0x8f, 0xdc, 0x3b, 0x39, 0x65, 0xa8, 0x0a, 0x82, 0x27, 0x43, 0x9b, 0xa5,
        0x6c, 0xa0, 0x4b, 0x0e, 0x7e, 0xce, 0x83, 0x2b, 0x29, 0xa5, 0x88, 0x80, 0xcf, 0x8d, 0x08,
        0x27, 0x5a, 0xef, 0xb1, 0x21, 0xd3, 0xb7, 0xec, 0x96, 0xc3, 0xce, 0x5c, 0x1b, 0x63, 0xd1,
        0x98, 0xd3, 0x39, 0x72, 0x06, 0xd7, 0xa0, 0x81, 0x85, 0x14, 0x8d, 0xe4, 0x46, 0x8d, 0x11,
        0x3e, 0xc8, 0xd9, 0x38, 0xf2, 0xeb, 0x8e, 0xb6, 0x05, 0x6f, 0x99, 0xca, 0x32, 0x50, 0x12,
        0xe3, 0xbc, 0xc5, 0xaf, 0x27, 0x08, 0x2b, 0xec, 0xd8, 0xb6, 0x3d, 0xaf, 0x37, 0x41, 0x2f,
        0x94, 0x1b, 0xac, 0x08, 0x99, 0x30, 0xe4, 0xc0, 0xd9, 0x01, 0xdf, 0xc6, 0xb3, 0xda, 0x87,
        0x02, 0x9f, 0xda, 0x4d, 0x3b, 0x25, 0x8d, 0xcc, 0xb8, 0x0b, 0x96, 0x2e, 0x03, 0x50, 0xec,
        0xbd, 0x51, 0x7f, 0x28, 0xda, 0xb6, 0xdd, 0x09};

    alt_u32 sig_r[12] = {0};
    alt_u32 sig_s[12] = {0};

    // Generate the signature using the message and keys and store it.
    generate_ecdsa_signature(sig_r, sig_s, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE);

    // Verify the generated signature
    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_pub_cy_384, (const alt_u32*)sig_r, (const alt_u32*)sig_s, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_generate_384_signature_with_multiple_sha_block)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_384[SHA384_LENGTH] = {
        0xcd, 0x80, 0x28, 0x3e, 0x15, 0x2c, 0x3f, 0x9f, 0x34, 0x68, 0x92, 0xbc, 0xbf, 0xce, 0x86, 0x1f,
        0x6d, 0x0a, 0x22, 0xae, 0x18, 0xdd, 0x2a, 0xa5, 0x93, 0x82, 0x0f, 0xd2, 0xbe, 0x43, 0x50, 0xa9,
        0x6b, 0xa3, 0x88, 0xa5, 0x1b, 0xfd, 0xb1, 0x4d, 0x42, 0x1e, 0x62, 0xd6, 0x11, 0xbc, 0x50, 0x70};

    const alt_u8 crypto_pub_cx_384[SHA384_LENGTH] = {
        0xe5, 0x42, 0x3d, 0x97, 0xff, 0xfb, 0x23, 0xa9, 0xa6, 0x2c, 0x98, 0x8a, 0x25, 0x90, 0x2f, 0x72,
        0xca, 0x19, 0xd1, 0x76, 0x60, 0x15, 0x80, 0x42, 0xd0, 0xf9, 0x5c, 0xf7, 0xcb, 0x05, 0x78, 0x86,
        0xf6, 0x70, 0x17, 0xb5, 0xab, 0x09, 0xe8, 0xc0, 0x96, 0xb7, 0xd3, 0x15, 0x2f, 0x52, 0x7e, 0x92};

    const alt_u8 crypto_pub_cy_384[SHA384_LENGTH] = {
        0xfd, 0x87, 0x43, 0x35, 0xd3, 0xfe, 0x31, 0xbb, 0x4e, 0xbe, 0xee, 0x38, 0xe2, 0x03, 0x64, 0x07,
        0x1e, 0xa1, 0x71, 0x65, 0xd9, 0xc1, 0x72, 0x54, 0xa5, 0x77, 0x81, 0x70, 0x4e, 0xbf, 0x03, 0xa4,
        0x3a, 0xdb, 0x7c, 0xdb, 0x18, 0x3f, 0xc3, 0x24, 0x06, 0x28, 0x97, 0x1a, 0x18, 0x78, 0xc3, 0xa2};

    const alt_u32 test_data_size = 768;

    const alt_u8 test_data[768] = {
			  0x09, 0x1c, 0x81, 0x91, 0xc4, 0x1d, 0x8b, 0x0f, 0x94, 0x65, 0x51, 0xa9,
			  0x5f, 0xcf, 0x95, 0xa5, 0x77, 0x7f, 0x9b, 0xa5, 0x73, 0xde, 0xf4, 0xf7,
			  0xfd, 0xf2, 0x0d, 0xe5, 0x49, 0xe1, 0x68, 0x41, 0xeb, 0x0a, 0x10, 0x19,
			  0x67, 0x86, 0xed, 0x4d, 0x3d, 0xeb, 0x64, 0xda, 0x00, 0x31, 0x68, 0x76,
			  0xf1, 0x2d, 0x8e, 0x41, 0xaf, 0x76, 0xee, 0x69, 0xbb, 0x97, 0x8c, 0xc8,
			  0xf0, 0x74, 0x7e, 0x8a, 0x11, 0x7a, 0x96, 0x1c, 0x49, 0x89, 0x3d, 0x6d,
			  0xb1, 0x5c, 0xaf, 0x2c, 0x18, 0xe6, 0xc6, 0xbd, 0x47, 0x3e, 0x16, 0xcb,
			  0x71, 0xb2, 0x56, 0x97, 0xbe, 0xa7, 0xe9, 0x5b, 0x18, 0x51, 0xaa, 0x14,
			  0xaa, 0xbc, 0xd0, 0x4c, 0x4d, 0xa0, 0x09, 0x41, 0xe0, 0x85, 0x89, 0x1f,
			  0x21, 0xf8, 0x63, 0x00, 0xaa, 0x4d, 0x4c, 0xed, 0x06, 0x4d, 0x67, 0xf9,
			  0x2d, 0x51, 0xa5, 0xac, 0xf5, 0x7b, 0x32, 0x77,
			  0xc7, 0x71, 0xe9, 0xb9, 0x6b, 0x60, 0x41, 0x41, 0xde, 0xbe, 0x6d, 0xb8,
			  0xbf, 0xb3, 0x72, 0xea, 0xf2, 0x61, 0x78, 0xe1, 0x03, 0x81, 0x7e, 0x41,
			  0x6f, 0xc1, 0xdd, 0x27, 0xe8, 0x64, 0x5f, 0xfd, 0x37, 0xb5, 0x85, 0x93,
			  0xc9, 0x13, 0x8e, 0x47, 0x53, 0x95, 0xdb, 0xee, 0xc4, 0x29, 0x87, 0x9a,
			  0xca, 0xcf, 0x67, 0x8d, 0x65, 0xd0, 0xe6, 0xe9, 0xf7, 0x09, 0x8a, 0xc9,
			  0x04, 0x90, 0xec, 0xd1, 0x18, 0x79, 0xc3, 0x38, 0x9f, 0xee, 0x8c, 0x5b,
			  0x1b, 0x9a, 0x0d, 0xb9, 0xf9, 0xff, 0xe5, 0x18, 0x8d, 0x76, 0x0a, 0x10,
			  0x19, 0x1f, 0x4a, 0x9a, 0xdd, 0x1e, 0x56, 0xdd, 0xca, 0x13, 0xa7, 0xe3,
			  0x31, 0xdd, 0x1a, 0xe6, 0x94, 0x77, 0x93, 0x08, 0x6a, 0x5f, 0x45, 0x82,
			  0x06, 0x63, 0x68, 0x25, 0x88, 0x86, 0x9f, 0x7b, 0x04, 0xe3, 0xa3, 0xd5,
			  0x3b, 0x5f, 0x1d, 0x9a, 0x39, 0xc8, 0xf5, 0xa2,
			  0x49, 0xfd, 0x14, 0x87, 0xbf, 0x27, 0x86, 0x89, 0x0e, 0x4a, 0x8a, 0x6a,
			  0x48, 0xb8, 0x08, 0xd5, 0x1b, 0xb5, 0x3a, 0x26, 0xbd, 0x5e, 0xdc, 0x8b,
			  0x2a, 0xeb, 0x71, 0xdc, 0x5c, 0x9e, 0x69, 0x5c, 0xdd, 0x5a, 0x8c, 0x1a,
			  0x3f, 0x62, 0xb1, 0x6c, 0xf4, 0x36, 0x74, 0x45, 0xa0, 0xc8, 0xe8, 0x86,
			  0x11, 0xa2, 0x5e, 0x30, 0x22, 0x00, 0xf2, 0xc7, 0x17, 0x48, 0xc8, 0xdd,
			  0x09, 0x66, 0xa0, 0x64, 0x69, 0x05, 0x25, 0x1c, 0x7a, 0x20, 0x68, 0x85,
			  0x86, 0xfd, 0xfe, 0xfe, 0x11, 0xb0, 0x2c, 0x11, 0x9e, 0x45, 0xe0, 0x47,
			  0xf1, 0xc1, 0x2f, 0xe2, 0xd3, 0xa2, 0xa6, 0x62, 0xf3, 0x40, 0x94, 0xdd,
			  0xac, 0x5b, 0x09, 0x53, 0x94, 0xdb, 0xa9, 0xe6, 0xc4, 0x36, 0xb3, 0x0b,
			  0x3f, 0x77, 0xfd, 0xa9, 0x98, 0x99, 0x53, 0x9b, 0x82, 0x65, 0x9c, 0xbe,
			  0xac, 0x60, 0x7b, 0x3e, 0x3b, 0xec, 0x9e, 0x79,
			  0xa4, 0x9c, 0x05, 0x20, 0x40, 0x06, 0xa8, 0x57, 0x81, 0xbe, 0xe6, 0x34,
			  0x8d, 0xd3, 0x63, 0x66, 0x7e, 0x82, 0x5f, 0x21, 0x57, 0x16, 0x74, 0xd4,
			  0x55, 0x3d, 0xa2, 0x38, 0xc7, 0x3b, 0xba, 0x18, 0x77, 0x89, 0xd4, 0xbb,
			  0xbb, 0x28, 0x80, 0xe2, 0x8a, 0xbd, 0x42, 0x3e, 0x11, 0x38, 0x59, 0x42,
			  0x5a, 0x70, 0x06, 0xa1, 0x1c, 0x32, 0x00, 0x95, 0xfb, 0x73, 0x47, 0x0e,
			  0xa0, 0x7b, 0x1b, 0x47, 0x06, 0x83, 0xec, 0x09, 0x3a, 0xa5, 0xe3, 0x67,
			  0x27, 0xfa, 0xd9, 0x76, 0x18, 0x61, 0xc0, 0x33, 0x83, 0x9b, 0x04, 0x87,
			  0xf3, 0xb9, 0xc8, 0x88, 0xf8, 0xc2, 0x34, 0x20, 0xfa, 0x91, 0xae, 0x40,
			  0x3e, 0x7b, 0x4c, 0x1b, 0xf7, 0xf9, 0x38, 0xb2, 0x4a, 0xc9, 0x0a, 0xc6,
			  0xed, 0x61, 0x5e, 0x86, 0x2d, 0x5d, 0x1b, 0x3e, 0x8a, 0xd9, 0x6b, 0x53,
			  0x2d, 0xbf, 0x95, 0x28, 0x43, 0xd4, 0x66, 0xe9,
			  0x7b, 0x80, 0xe0, 0x81, 0x45, 0x20, 0x94, 0x11, 0x4a, 0xcf, 0x80, 0x36,
			  0xb0, 0x8e, 0xbc, 0xe9, 0xe0, 0x4d, 0xb1, 0xf5, 0x0e, 0x78, 0xf7, 0x57,
			  0x73, 0xce, 0x87, 0x7c, 0xc9, 0x4d, 0x2b, 0xd9, 0x81, 0x48, 0xcd, 0x20,
			  0x33, 0xb1, 0xee, 0xa5, 0x69, 0x20, 0x9c, 0x6c, 0x0b, 0xdc, 0xbf, 0x5c,
			  0xb2, 0xf1, 0x0f, 0x20, 0xba, 0x41, 0x21, 0xfd, 0x13, 0xff, 0xd6, 0x5c,
			  0x92, 0x31, 0x8c, 0xbc, 0x72, 0xf4, 0xd2, 0xcb, 0x37, 0x1c, 0x79, 0x83,
			  0x5b, 0x27, 0x27, 0xc3, 0x7a, 0xe9, 0x99, 0x46, 0x08, 0x4e, 0xe6, 0x70,
			  0x87, 0x17, 0x82, 0x66, 0x1f, 0x67, 0xf8, 0x9f, 0x88, 0x2e, 0x1f, 0x13,
			  0x9b, 0xb1, 0xfe, 0xd2, 0x63, 0x7b, 0xac, 0x42, 0xda, 0x45, 0x4f, 0x61,
			  0x6d, 0xb5, 0x5f, 0x08, 0xd4, 0xdb, 0x54, 0x38, 0x24, 0xc2, 0x0c, 0xca,
			  0x8e, 0xfb, 0x0c, 0x6e, 0x21, 0x8a, 0x9a, 0xdd,
			  0x23, 0xf9, 0xe8, 0xcb, 0xed, 0xb0, 0x34, 0x30, 0xed, 0x6a, 0x86, 0xa5,
			  0xaf, 0xd9, 0xf2, 0x34, 0x99, 0x81, 0x62, 0x63, 0x07, 0xf5, 0x2b, 0x19,
			  0x1f, 0xd1, 0x08, 0xe6, 0x98, 0x6f, 0x3f, 0xf3, 0x9d, 0xba, 0x96, 0x2e,
			  0x72, 0x65, 0xd3, 0x6b, 0x71, 0x85, 0x40, 0x7c, 0x54, 0x64, 0x77, 0xe4,
			  0x45, 0xa7, 0x87, 0x99, 0xbf, 0x87, 0x22, 0xaa, 0x07, 0xa7, 0x86, 0x52,
			  0xd6, 0x3e, 0xf7, 0x56, 0x4c, 0x84, 0x14, 0xe5, 0x5a, 0x2f, 0xb8, 0x69,
			  0x2c, 0xd8, 0x34, 0x34, 0xa9, 0x78, 0xb7, 0xb4, 0x4b, 0x6a, 0xbc, 0x8a,
			  0xa8, 0x13, 0x94, 0xda, 0x3f, 0x65, 0xf0, 0xc1, 0x84, 0x59, 0x65, 0x71,
			  0x6b, 0x8e, 0xd9, 0xfc, 0x40, 0x36, 0x18, 0xf7, 0xfb, 0x3e, 0xc4, 0x2c,
			  0xc8, 0xd8, 0xaa, 0x50, 0xba, 0x9d, 0x3c, 0x38, 0xb4, 0xbd, 0xf1, 0x7a,
			  0x5d, 0x06, 0xe9, 0x84, 0x94, 0x01, 0x57, 0xf1
    };

    alt_u32 sig_r[12] = {0};
    alt_u32 sig_s[12] = {0};

    generate_ecdsa_signature(sig_r, sig_s, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE);

    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_pub_cy_384, (const alt_u32*)sig_r, (const alt_u32*)sig_s, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));
}

/**
 * @brief This test covers the ecdsa public key generation, signature generation
 * with the key components and signature verification for ECDSA-384.
 */
TEST_F(PFRCryptoTest, test_ecdsa_384_flow)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_384[SHA384_LENGTH] = {
        0xcd, 0x80, 0x28, 0x3e, 0x15, 0x2c, 0x3f, 0x9f, 0x34, 0x68, 0x92, 0xbc, 0xbf, 0xce, 0x86, 0x1f,
        0x6d, 0x0a, 0x22, 0xae, 0x18, 0xdd, 0x2a, 0xa5, 0x93, 0x82, 0x0f, 0xd2, 0xbe, 0x43, 0x50, 0xa9,
        0x6b, 0xa3, 0x88, 0xa5, 0x1b, 0xfd, 0xb1, 0x4d, 0x42, 0x1e, 0x62, 0xd6, 0x11, 0xbc, 0x50, 0x70};

    alt_u32 crypto_pub_cx_384[SHA384_LENGTH/4] = {0};

    alt_u32 crypto_pub_cy_384[SHA384_LENGTH/4] = {0};

    const alt_u32 test_data_size = 128;

    const alt_u8 test_data[128] = {
        0x86, 0x3a, 0x60, 0x8f, 0xdc, 0x3b, 0x39, 0x65, 0xa8, 0x0a, 0x82, 0x27, 0x43, 0x9b, 0xa5,
        0x6c, 0xa0, 0x4b, 0x0e, 0x7e, 0xce, 0x83, 0x2b, 0x29, 0xa5, 0x88, 0x80, 0xcf, 0x8d, 0x08,
        0x27, 0x5a, 0xef, 0xb1, 0x21, 0xd3, 0xb7, 0xec, 0x96, 0xc3, 0xce, 0x5c, 0x1b, 0x63, 0xd1,
        0x98, 0xd3, 0x39, 0x72, 0x06, 0xd7, 0xa0, 0x81, 0x85, 0x14, 0x8d, 0xe4, 0x46, 0x8d, 0x11,
        0x3e, 0xc8, 0xd9, 0x38, 0xf2, 0xeb, 0x8e, 0xb6, 0x05, 0x6f, 0x99, 0xca, 0x32, 0x50, 0x12,
        0xe3, 0xbc, 0xc5, 0xaf, 0x27, 0x08, 0x2b, 0xec, 0xd8, 0xb6, 0x3d, 0xaf, 0x37, 0x41, 0x2f,
        0x94, 0x1b, 0xac, 0x08, 0x99, 0x30, 0xe4, 0xc0, 0xd9, 0x01, 0xdf, 0xc6, 0xb3, 0xda, 0x87,
        0x02, 0x9f, 0xda, 0x4d, 0x3b, 0x25, 0x8d, 0xcc, 0xb8, 0x0b, 0x96, 0x2e, 0x03, 0x50, 0xec,
        0xbd, 0x51, 0x7f, 0x28, 0xda, 0xb6, 0xdd, 0x09};

    alt_u32 sig_r_1[12] = {0};
    alt_u32 sig_s_1[12] = {0};

    // Generate public keys from priv key
    generate_pubkey((alt_u32*)crypto_pub_cx_384, (alt_u32*)crypto_pub_cy_384, (alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE);

    // Generate signature
    generate_ecdsa_signature(sig_r_1, sig_s_1, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE);

    // Verify signature
    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_pub_cy_384, (const alt_u32*)sig_r_1, (const alt_u32*)sig_s_1, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));
}

/**
 * @brief This test is to check for the randomness of the signature
 * generated. It is important to have a different signature each time
 * they are generated.
 */
TEST_F(PFRCryptoTest, test_randomness_of_ecdsa_384_signature)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_384[SHA384_LENGTH] = {
        0xcd, 0x80, 0x28, 0x3e, 0x15, 0x2c, 0x3f, 0x9f, 0x34, 0x68, 0x92, 0xbc, 0xbf, 0xce, 0x86, 0x1f,
        0x6d, 0x0a, 0x22, 0xae, 0x18, 0xdd, 0x2a, 0xa5, 0x93, 0x82, 0x0f, 0xd2, 0xbe, 0x43, 0x50, 0xa9,
        0x6b, 0xa3, 0x88, 0xa5, 0x1b, 0xfd, 0xb1, 0x4d, 0x42, 0x1e, 0x62, 0xd6, 0x11, 0xbc, 0x50, 0x70};

    const alt_u8 crypto_pub_cx_384[SHA384_LENGTH] = {
        0xe5, 0x42, 0x3d, 0x97, 0xff, 0xfb, 0x23, 0xa9, 0xa6, 0x2c, 0x98, 0x8a, 0x25, 0x90, 0x2f, 0x72,
        0xca, 0x19, 0xd1, 0x76, 0x60, 0x15, 0x80, 0x42, 0xd0, 0xf9, 0x5c, 0xf7, 0xcb, 0x05, 0x78, 0x86,
        0xf6, 0x70, 0x17, 0xb5, 0xab, 0x09, 0xe8, 0xc0, 0x96, 0xb7, 0xd3, 0x15, 0x2f, 0x52, 0x7e, 0x92};

    const alt_u8 crypto_pub_cy_384[SHA384_LENGTH] = {
        0xfd, 0x87, 0x43, 0x35, 0xd3, 0xfe, 0x31, 0xbb, 0x4e, 0xbe, 0xee, 0x38, 0xe2, 0x03, 0x64, 0x07,
        0x1e, 0xa1, 0x71, 0x65, 0xd9, 0xc1, 0x72, 0x54, 0xa5, 0x77, 0x81, 0x70, 0x4e, 0xbf, 0x03, 0xa4,
        0x3a, 0xdb, 0x7c, 0xdb, 0x18, 0x3f, 0xc3, 0x24, 0x06, 0x28, 0x97, 0x1a, 0x18, 0x78, 0xc3, 0xa2};

    const alt_u32 test_data_size = 128;

    const alt_u8 test_data[128] = {
        0x86, 0x3a, 0x60, 0x8f, 0xdc, 0x3b, 0x39, 0x65, 0xa8, 0x0a, 0x82, 0x27, 0x43, 0x9b, 0xa5,
        0x6c, 0xa0, 0x4b, 0x0e, 0x7e, 0xce, 0x83, 0x2b, 0x29, 0xa5, 0x88, 0x80, 0xcf, 0x8d, 0x08,
        0x27, 0x5a, 0xef, 0xb1, 0x21, 0xd3, 0xb7, 0xec, 0x96, 0xc3, 0xce, 0x5c, 0x1b, 0x63, 0xd1,
        0x98, 0xd3, 0x39, 0x72, 0x06, 0xd7, 0xa0, 0x81, 0x85, 0x14, 0x8d, 0xe4, 0x46, 0x8d, 0x11,
        0x3e, 0xc8, 0xd9, 0x38, 0xf2, 0xeb, 0x8e, 0xb6, 0x05, 0x6f, 0x99, 0xca, 0x32, 0x50, 0x12,
        0xe3, 0xbc, 0xc5, 0xaf, 0x27, 0x08, 0x2b, 0xec, 0xd8, 0xb6, 0x3d, 0xaf, 0x37, 0x41, 0x2f,
        0x94, 0x1b, 0xac, 0x08, 0x99, 0x30, 0xe4, 0xc0, 0xd9, 0x01, 0xdf, 0xc6, 0xb3, 0xda, 0x87,
        0x02, 0x9f, 0xda, 0x4d, 0x3b, 0x25, 0x8d, 0xcc, 0xb8, 0x0b, 0x96, 0x2e, 0x03, 0x50, 0xec,
        0xbd, 0x51, 0x7f, 0x28, 0xda, 0xb6, 0xdd, 0x09};

    alt_u32 sig_r_1[12] = {0};
    alt_u32 sig_s_1[12] = {0};
    alt_u32 sig_r_2[12] = {0};
    alt_u32 sig_s_2[12] = {0};
    alt_u32 sig_r_3[12] = {0};
    alt_u32 sig_s_3[12] = {0};

    generate_ecdsa_signature(sig_r_1, sig_s_1, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE);

    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_pub_cy_384, (const alt_u32*)sig_r_1, (const alt_u32*)sig_s_1, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));

    generate_ecdsa_signature(sig_r_2, sig_s_2, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE);

    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_pub_cy_384, (const alt_u32*)sig_r_2, (const alt_u32*)sig_s_2, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));

    generate_ecdsa_signature(sig_r_3, sig_s_3, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE);

    EXPECT_TRUE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_pub_cy_384, (const alt_u32*)sig_r_3, (const alt_u32*)sig_s_3, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));

    alt_u32 is_random = 1;

    // Test the randomness of 3 signatures.
    for (alt_u32 i = 0; i < SHA384_LENGTH/4; i++)
    {
        if ((sig_r_1[i] == sig_r_2[i]) || (sig_s_1[i] == sig_s_2[i]) || (sig_r_3[i] == sig_r_2[i]) || (sig_s_3[i] == sig_s_2[i]))
        {
        	is_random = 0;
        }
    }

    EXPECT_EQ(alt_u32(1), is_random);
}

/**
 * @brief Force health test failure within entropy
 */
TEST_F(PFRCryptoTest, test_health_circuit_forced_error_of_entropy_extractor)
{
    alt_u32 entropy_sample_one[64] = {0};
    // Force health to fail within the crypto mock
    SYSTEM_MOCK::get()->force_mock_entropy_error();

    // Expect zero for error
    EXPECT_EQ(extract_entropy_data((alt_u32*)entropy_sample_one, SHA384_HMAC_ENTROPY), alt_u32 (0));

    // Expect no written value
    for (alt_u32 i = 0; i < SHA384_HMAC_ENTROPY; i++)
    {
        EXPECT_EQ(entropy_sample_one[i], alt_u32(0));
    }
}

/**
 * @brief Test the generation of ecdsa-384 signature with 128 bytes data
 * with entropy error circuit.
 */
TEST_F(PFRCryptoTest, test_generate_384_signature_single_sha_block_with_entropy_error)
{
    // Assuming this is the private keys needed to create public keys
    const alt_u8 crypto_ec_da_384[SHA384_LENGTH] = {
        0xcd, 0x80, 0x28, 0x3e, 0x15, 0x2c, 0x3f, 0x9f, 0x34, 0x68, 0x92, 0xbc, 0xbf, 0xce, 0x86, 0x1f,
        0x6d, 0x0a, 0x22, 0xae, 0x18, 0xdd, 0x2a, 0xa5, 0x93, 0x82, 0x0f, 0xd2, 0xbe, 0x43, 0x50, 0xa9,
        0x6b, 0xa3, 0x88, 0xa5, 0x1b, 0xfd, 0xb1, 0x4d, 0x42, 0x1e, 0x62, 0xd6, 0x11, 0xbc, 0x50, 0x70};

    const alt_u8 crypto_pub_cx_384[SHA384_LENGTH] = {
        0xe5, 0x42, 0x3d, 0x97, 0xff, 0xfb, 0x23, 0xa9, 0xa6, 0x2c, 0x98, 0x8a, 0x25, 0x90, 0x2f, 0x72,
        0xca, 0x19, 0xd1, 0x76, 0x60, 0x15, 0x80, 0x42, 0xd0, 0xf9, 0x5c, 0xf7, 0xcb, 0x05, 0x78, 0x86,
        0xf6, 0x70, 0x17, 0xb5, 0xab, 0x09, 0xe8, 0xc0, 0x96, 0xb7, 0xd3, 0x15, 0x2f, 0x52, 0x7e, 0x92};

    const alt_u8 crypto_pub_cy_384[SHA384_LENGTH] = {
        0xfd, 0x87, 0x43, 0x35, 0xd3, 0xfe, 0x31, 0xbb, 0x4e, 0xbe, 0xee, 0x38, 0xe2, 0x03, 0x64, 0x07,
        0x1e, 0xa1, 0x71, 0x65, 0xd9, 0xc1, 0x72, 0x54, 0xa5, 0x77, 0x81, 0x70, 0x4e, 0xbf, 0x03, 0xa4,
        0x3a, 0xdb, 0x7c, 0xdb, 0x18, 0x3f, 0xc3, 0x24, 0x06, 0x28, 0x97, 0x1a, 0x18, 0x78, 0xc3, 0xa2};

    const alt_u32 test_data_size = 128;

    const alt_u8 test_data[128] = {
        0x86, 0x3a, 0x60, 0x8f, 0xdc, 0x3b, 0x39, 0x65, 0xa8, 0x0a, 0x82, 0x27, 0x43, 0x9b, 0xa5,
        0x6c, 0xa0, 0x4b, 0x0e, 0x7e, 0xce, 0x83, 0x2b, 0x29, 0xa5, 0x88, 0x80, 0xcf, 0x8d, 0x08,
        0x27, 0x5a, 0xef, 0xb1, 0x21, 0xd3, 0xb7, 0xec, 0x96, 0xc3, 0xce, 0x5c, 0x1b, 0x63, 0xd1,
        0x98, 0xd3, 0x39, 0x72, 0x06, 0xd7, 0xa0, 0x81, 0x85, 0x14, 0x8d, 0xe4, 0x46, 0x8d, 0x11,
        0x3e, 0xc8, 0xd9, 0x38, 0xf2, 0xeb, 0x8e, 0xb6, 0x05, 0x6f, 0x99, 0xca, 0x32, 0x50, 0x12,
        0xe3, 0xbc, 0xc5, 0xaf, 0x27, 0x08, 0x2b, 0xec, 0xd8, 0xb6, 0x3d, 0xaf, 0x37, 0x41, 0x2f,
        0x94, 0x1b, 0xac, 0x08, 0x99, 0x30, 0xe4, 0xc0, 0xd9, 0x01, 0xdf, 0xc6, 0xb3, 0xda, 0x87,
        0x02, 0x9f, 0xda, 0x4d, 0x3b, 0x25, 0x8d, 0xcc, 0xb8, 0x0b, 0x96, 0x2e, 0x03, 0x50, 0xec,
        0xbd, 0x51, 0x7f, 0x28, 0xda, 0xb6, 0xdd, 0x09};

    alt_u32 sig_r[12] = {0};
    alt_u32 sig_s[12] = {0};

    // Force health to fail within the crypto mock
    SYSTEM_MOCK::get()->force_mock_entropy_error();

    // Generate the signature using the message and keys and store it.
    EXPECT_EQ(generate_ecdsa_signature(sig_r, sig_s, (const alt_u32*)test_data, test_data_size, (const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE), alt_u32(0));

    // Verify the generated signature and expect fail
    EXPECT_FALSE(verify_ecdsa_and_sha((const alt_u32*)crypto_pub_cx_384, (const alt_u32*)crypto_pub_cy_384, (const alt_u32*)sig_r, (const alt_u32*)sig_s, 0, (const alt_u32*)test_data, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));
}

TEST_F(PFRCryptoTest, test_generate_pubkey_with_entropy_error)
{
    const alt_u32 test_data_size = 768;

	const alt_u8 test_data[768] = {
			  0x09, 0x1c, 0x81, 0x91, 0xc4, 0x1d, 0x8b, 0x0f, 0x94, 0x65, 0x51, 0xa9,
			  0x5f, 0xcf, 0x95, 0xa5, 0x77, 0x7f, 0x9b, 0xa5, 0x73, 0xde, 0xf4, 0xf7,
			  0xfd, 0xf2, 0x0d, 0xe5, 0x49, 0xe1, 0x68, 0x41, 0xeb, 0x0a, 0x10, 0x19,
			  0x67, 0x86, 0xed, 0x4d, 0x3d, 0xeb, 0x64, 0xda, 0x00, 0x31, 0x68, 0x76,
			  0xf1, 0x2d, 0x8e, 0x41, 0xaf, 0x76, 0xee, 0x69, 0xbb, 0x97, 0x8c, 0xc8,
			  0xf0, 0x74, 0x7e, 0x8a, 0x11, 0x7a, 0x96, 0x1c, 0x49, 0x89, 0x3d, 0x6d,
			  0xb1, 0x5c, 0xaf, 0x2c, 0x18, 0xe6, 0xc6, 0xbd, 0x47, 0x3e, 0x16, 0xcb,
			  0x71, 0xb2, 0x56, 0x97, 0xbe, 0xa7, 0xe9, 0x5b, 0x18, 0x51, 0xaa, 0x14,
			  0xaa, 0xbc, 0xd0, 0x4c, 0x4d, 0xa0, 0x09, 0x41, 0xe0, 0x85, 0x89, 0x1f,
			  0x21, 0xf8, 0x63, 0x00, 0xaa, 0x4d, 0x4c, 0xed, 0x06, 0x4d, 0x67, 0xf9,
			  0x2d, 0x51, 0xa5, 0xac, 0xf5, 0x7b, 0x32, 0x77,
			  0xc7, 0x71, 0xe9, 0xb9, 0x6b, 0x60, 0x41, 0x41, 0xde, 0xbe, 0x6d, 0xb8,
			  0xbf, 0xb3, 0x72, 0xea, 0xf2, 0x61, 0x78, 0xe1, 0x03, 0x81, 0x7e, 0x41,
			  0x6f, 0xc1, 0xdd, 0x27, 0xe8, 0x64, 0x5f, 0xfd, 0x37, 0xb5, 0x85, 0x93,
			  0xc9, 0x13, 0x8e, 0x47, 0x53, 0x95, 0xdb, 0xee, 0xc4, 0x29, 0x87, 0x9a,
			  0xca, 0xcf, 0x67, 0x8d, 0x65, 0xd0, 0xe6, 0xe9, 0xf7, 0x09, 0x8a, 0xc9,
			  0x04, 0x90, 0xec, 0xd1, 0x18, 0x79, 0xc3, 0x38, 0x9f, 0xee, 0x8c, 0x5b,
			  0x1b, 0x9a, 0x0d, 0xb9, 0xf9, 0xff, 0xe5, 0x18, 0x8d, 0x76, 0x0a, 0x10,
			  0x19, 0x1f, 0x4a, 0x9a, 0xdd, 0x1e, 0x56, 0xdd, 0xca, 0x13, 0xa7, 0xe3,
			  0x31, 0xdd, 0x1a, 0xe6, 0x94, 0x77, 0x93, 0x08, 0x6a, 0x5f, 0x45, 0x82,
			  0x06, 0x63, 0x68, 0x25, 0x88, 0x86, 0x9f, 0x7b, 0x04, 0xe3, 0xa3, 0xd5,
			  0x3b, 0x5f, 0x1d, 0x9a, 0x39, 0xc8, 0xf5, 0xa2,
			  0x49, 0xfd, 0x14, 0x87, 0xbf, 0x27, 0x86, 0x89, 0x0e, 0x4a, 0x8a, 0x6a,
			  0x48, 0xb8, 0x08, 0xd5, 0x1b, 0xb5, 0x3a, 0x26, 0xbd, 0x5e, 0xdc, 0x8b,
			  0x2a, 0xeb, 0x71, 0xdc, 0x5c, 0x9e, 0x69, 0x5c, 0xdd, 0x5a, 0x8c, 0x1a,
			  0x3f, 0x62, 0xb1, 0x6c, 0xf4, 0x36, 0x74, 0x45, 0xa0, 0xc8, 0xe8, 0x86,
			  0x11, 0xa2, 0x5e, 0x30, 0x22, 0x00, 0xf2, 0xc7, 0x17, 0x48, 0xc8, 0xdd,
			  0x09, 0x66, 0xa0, 0x64, 0x69, 0x05, 0x25, 0x1c, 0x7a, 0x20, 0x68, 0x85,
			  0x86, 0xfd, 0xfe, 0xfe, 0x11, 0xb0, 0x2c, 0x11, 0x9e, 0x45, 0xe0, 0x47,
			  0xf1, 0xc1, 0x2f, 0xe2, 0xd3, 0xa2, 0xa6, 0x62, 0xf3, 0x40, 0x94, 0xdd,
			  0xac, 0x5b, 0x09, 0x53, 0x94, 0xdb, 0xa9, 0xe6, 0xc4, 0x36, 0xb3, 0x0b,
			  0x3f, 0x77, 0xfd, 0xa9, 0x98, 0x99, 0x53, 0x9b, 0x82, 0x65, 0x9c, 0xbe,
			  0xac, 0x60, 0x7b, 0x3e, 0x3b, 0xec, 0x9e, 0x79,
			  0xa4, 0x9c, 0x05, 0x20, 0x40, 0x06, 0xa8, 0x57, 0x81, 0xbe, 0xe6, 0x34,
			  0x8d, 0xd3, 0x63, 0x66, 0x7e, 0x82, 0x5f, 0x21, 0x57, 0x16, 0x74, 0xd4,
			  0x55, 0x3d, 0xa2, 0x38, 0xc7, 0x3b, 0xba, 0x18, 0x77, 0x89, 0xd4, 0xbb,
			  0xbb, 0x28, 0x80, 0xe2, 0x8a, 0xbd, 0x42, 0x3e, 0x11, 0x38, 0x59, 0x42,
			  0x5a, 0x70, 0x06, 0xa1, 0x1c, 0x32, 0x00, 0x95, 0xfb, 0x73, 0x47, 0x0e,
			  0xa0, 0x7b, 0x1b, 0x47, 0x06, 0x83, 0xec, 0x09, 0x3a, 0xa5, 0xe3, 0x67,
			  0x27, 0xfa, 0xd9, 0x76, 0x18, 0x61, 0xc0, 0x33, 0x83, 0x9b, 0x04, 0x87,
			  0xf3, 0xb9, 0xc8, 0x88, 0xf8, 0xc2, 0x34, 0x20, 0xfa, 0x91, 0xae, 0x40,
			  0x3e, 0x7b, 0x4c, 0x1b, 0xf7, 0xf9, 0x38, 0xb2, 0x4a, 0xc9, 0x0a, 0xc6,
			  0xed, 0x61, 0x5e, 0x86, 0x2d, 0x5d, 0x1b, 0x3e, 0x8a, 0xd9, 0x6b, 0x53,
			  0x2d, 0xbf, 0x95, 0x28, 0x43, 0xd4, 0x66, 0xe9,
			  0x7b, 0x80, 0xe0, 0x81, 0x45, 0x20, 0x94, 0x11, 0x4a, 0xcf, 0x80, 0x36,
			  0xb0, 0x8e, 0xbc, 0xe9, 0xe0, 0x4d, 0xb1, 0xf5, 0x0e, 0x78, 0xf7, 0x57,
			  0x73, 0xce, 0x87, 0x7c, 0xc9, 0x4d, 0x2b, 0xd9, 0x81, 0x48, 0xcd, 0x20,
			  0x33, 0xb1, 0xee, 0xa5, 0x69, 0x20, 0x9c, 0x6c, 0x0b, 0xdc, 0xbf, 0x5c,
			  0xb2, 0xf1, 0x0f, 0x20, 0xba, 0x41, 0x21, 0xfd, 0x13, 0xff, 0xd6, 0x5c,
			  0x92, 0x31, 0x8c, 0xbc, 0x72, 0xf4, 0xd2, 0xcb, 0x37, 0x1c, 0x79, 0x83,
			  0x5b, 0x27, 0x27, 0xc3, 0x7a, 0xe9, 0x99, 0x46, 0x08, 0x4e, 0xe6, 0x70,
			  0x87, 0x17, 0x82, 0x66, 0x1f, 0x67, 0xf8, 0x9f, 0x88, 0x2e, 0x1f, 0x13,
			  0x9b, 0xb1, 0xfe, 0xd2, 0x63, 0x7b, 0xac, 0x42, 0xda, 0x45, 0x4f, 0x61,
			  0x6d, 0xb5, 0x5f, 0x08, 0xd4, 0xdb, 0x54, 0x38, 0x24, 0xc2, 0x0c, 0xca,
			  0x8e, 0xfb, 0x0c, 0x6e, 0x21, 0x8a, 0x9a, 0xdd,
			  0x23, 0xf9, 0xe8, 0xcb, 0xed, 0xb0, 0x34, 0x30, 0xed, 0x6a, 0x86, 0xa5,
			  0xaf, 0xd9, 0xf2, 0x34, 0x99, 0x81, 0x62, 0x63, 0x07, 0xf5, 0x2b, 0x19,
			  0x1f, 0xd1, 0x08, 0xe6, 0x98, 0x6f, 0x3f, 0xf3, 0x9d, 0xba, 0x96, 0x2e,
			  0x72, 0x65, 0xd3, 0x6b, 0x71, 0x85, 0x40, 0x7c, 0x54, 0x64, 0x77, 0xe4,
			  0x45, 0xa7, 0x87, 0x99, 0xbf, 0x87, 0x22, 0xaa, 0x07, 0xa7, 0x86, 0x52,
			  0xd6, 0x3e, 0xf7, 0x56, 0x4c, 0x84, 0x14, 0xe5, 0x5a, 0x2f, 0xb8, 0x69,
			  0x2c, 0xd8, 0x34, 0x34, 0xa9, 0x78, 0xb7, 0xb4, 0x4b, 0x6a, 0xbc, 0x8a,
			  0xa8, 0x13, 0x94, 0xda, 0x3f, 0x65, 0xf0, 0xc1, 0x84, 0x59, 0x65, 0x71,
			  0x6b, 0x8e, 0xd9, 0xfc, 0x40, 0x36, 0x18, 0xf7, 0xfb, 0x3e, 0xc4, 0x2c,
			  0xc8, 0xd8, 0xaa, 0x50, 0xba, 0x9d, 0x3c, 0x38, 0xb4, 0xbd, 0xf1, 0x7a,
			  0x5d, 0x06, 0xe9, 0x84, 0x94, 0x01, 0x57, 0xf1
	};

	const alt_u8 expected_hash[SHA384_LENGTH] = {
			  0xd1, 0x61, 0xbe, 0xce, 0xf2, 0x91, 0x4c, 0xb9, 0xd7, 0x32, 0x31, 0xac,
			  0x4f, 0xe0, 0x44, 0xc1, 0xfc, 0xa6, 0xee, 0xe2, 0x58, 0x8b, 0x41, 0x8c,
			  0x89, 0xb7, 0xfa, 0x56, 0x4f, 0x62, 0x14, 0x4b, 0xca, 0xa8, 0x2a, 0xdb,
			  0x3d, 0xa1, 0x64, 0xc1, 0xc2, 0xbe, 0xff, 0x08, 0x66, 0xea, 0x89, 0x28
	};

	const alt_u8 test_pubkey_cx[SHA384_LENGTH] = {
			  0x48, 0x0c, 0x25, 0x99, 0xcd, 0xeb, 0x52, 0xa3, 0x1a, 0x7a, 0x34, 0x31,
			  0x44, 0xd6, 0x8b, 0x76, 0x3f, 0xb6, 0x4d, 0x62, 0x57, 0x97, 0xcc, 0x59,
			  0x90, 0x4c, 0x68, 0x4f, 0x0f, 0x8d, 0x94, 0x2f, 0x43, 0xea, 0xb1, 0xc5,
			  0x34, 0x1d, 0xcb, 0xb7, 0x01, 0x98, 0x46, 0x8b, 0x92, 0xca, 0xec, 0xd3
	};

	const alt_u8 test_pubkey_cy[SHA384_LENGTH] = {
			  0xfe, 0xee, 0x25, 0x65, 0x4a, 0xfc, 0xde, 0xed, 0xdd, 0x44, 0x28, 0x05,
			  0x39, 0x2e, 0x68, 0xc0, 0x3e, 0xce, 0xdd, 0x98, 0x22, 0x83, 0x54, 0x32,
			  0x87, 0x02, 0xf3, 0x10, 0x19, 0x7f, 0xf0, 0x9c, 0xee, 0xcf, 0xe4, 0x39,
			  0x70, 0xda, 0x66, 0xac, 0x3f, 0x91, 0xd8, 0xd9, 0x30, 0xb8, 0xce, 0xae
	};

	const alt_u8 test_sig_r[SHA384_LENGTH] = {
			  0x59, 0x16, 0xe5, 0xde, 0x66, 0xb6, 0x9e, 0xf7, 0x38, 0x77, 0xcf, 0x96,
			  0xf6, 0x61, 0xac, 0x3e, 0x31, 0xcd, 0x1e, 0xb4, 0xff, 0xa5, 0x3d, 0xe2,
			  0xd0, 0xf7, 0x38, 0x3d, 0xd0, 0xfb, 0x05, 0x88, 0x9f, 0x65, 0x96, 0x9a,
			  0x96, 0x2c, 0x97, 0x61, 0xa6, 0xa8, 0x84, 0xc9, 0x4a, 0x85, 0x04, 0x0b
	};

	const alt_u8 test_sig_s[SHA384_LENGTH] = {
			  0x2a, 0xab, 0x65, 0x05, 0x60, 0x90, 0x54, 0x51, 0x80, 0xf0, 0xe5, 0x4a,
			  0x23, 0x9f, 0x00, 0x79, 0x1c, 0xfe, 0x49, 0x4e, 0xfd, 0x15, 0x0a, 0xd3,
			  0x06, 0x26, 0x25, 0x5e, 0xdf, 0x3d, 0x7f, 0xb2, 0x3b, 0x57, 0x8f, 0x69,
			  0x83, 0xec, 0x0a, 0x03, 0x71, 0xe7, 0x8e, 0xc5, 0xe6, 0x06, 0xdd, 0x53
	};

    alt_u32* td_crypto_data_ptr = (alt_u32*) test_data;
    alt_u32* td_expected_hash_ptr = (alt_u32*) expected_hash;

    EXPECT_EQ(alt_u32(1), verify_sha(td_expected_hash_ptr, 0, td_crypto_data_ptr, test_data_size, CRYPTO_384_MODE, DISENGAGE_DMA));

    EXPECT_EQ(alt_u32(1),
              verify_ecdsa_and_sha((alt_u32*) test_pubkey_cx,
                                   (alt_u32*) test_pubkey_cy,
                                   (alt_u32*) test_sig_r,
                                   (alt_u32*) test_sig_s,
								   0,
                                   (alt_u32*) test_data,
                                   test_data_size,
                                   CRYPTO_384_MODE,
								   DISENGAGE_DMA));

    static const alt_u8 crypto_ec_da_384[SHA384_LENGTH] = {
        0xcd, 0x80, 0x28, 0x3e, 0x15, 0x2c, 0x3f, 0x9f, 0x34, 0x68, 0x92, 0xbc, 0xbf, 0xce, 0x86, 0x1f,
        0x6d, 0x0a, 0x22, 0xae, 0x18, 0xdd, 0x2a, 0xa5, 0x93, 0x82, 0x0f, 0xd2, 0xbe, 0x43, 0x50, 0xa9,
        0x6b, 0xa3, 0x88, 0xa5, 0x1b, 0xfd, 0xb1, 0x4d, 0x42, 0x1e, 0x62, 0xd6, 0x11, 0xbc, 0x50, 0x70};

    alt_u32 pubkey_cx[12] = {0};
    alt_u32 pubkey_cy[12] = {0};

    // Force health to fail within the crypto mock
    SYSTEM_MOCK::get()->force_mock_entropy_error();

    // generate_pubkey will return 0 due to the entropy error.
    EXPECT_EQ(alt_u32(0), generate_pubkey((alt_u32*)pubkey_cx, (alt_u32*)pubkey_cy, (alt_u32*)crypto_ec_da_384, CRYPTO_384_MODE));
}
